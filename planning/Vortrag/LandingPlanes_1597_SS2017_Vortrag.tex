 % $Header$

\documentclass[
	xcolor=dvipsnames,
%	handout,
	hideallsubsections
]{beamer} %xcolor=dvipsnames
%\documentclass[xcolor=dvipsnames, handout]{beamer} %xcolor=dvipsnames

\usepackage{pgfpages}

\mode<presentation>
{
	\usetheme{Rochester}
	\usecolortheme{wolverine}
%	\usecolortheme[named=TealBlue]{structure}
%	\usecolortheme[named=Dandelion]{structure}
	
	\setbeamercovered{transparent}
	% or whatever (possibly just delete it)
%	\setbeameroption{show notes} % un-comment to see the notes
%	\setbeameroption{show notes on second screen=right}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This LaTeX Beamer file is based on the solution template for:

% - Giving a talk on some subject.
% - The talk is between 15min and 45min long.
% - Style is ornate.

% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thank you so much Till :-)


\usepackage[ngerman]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
 
\input{structure.tex} % Include the structure.tex file which specified the document structure and layout


% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\title[Notlandefelder aus Höhendaten] % (optional, use only with long paper titles)
{Erkennung von Notlandefeldern aus Höhendaten: \\
	Parallele Implementierung der Durchmusterung mit \texttt{pThreads}}

\author[] % (optional, use only with lots of authors)
{Felix~Eckstein, Dr. Björn Wittich}
% - Use the \inst{?} command only if the authors have different
%   affiliation.

%\institute[FernUni Hagen] % (optional, but mostly needed)
%{
%}
  
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[] % (optional)
{``1597 -- Fachpraktikum Parallele Programmierung''\\
	im Sommersemester 2017 an der FernUniversität Hagen\\
23. September 2017}

\subject{Talks}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1cm]{university-logo}{images/HannoverJs.png}
  \pgfdeclareimage[height=1cm]{university-logo}{images/UniHagen.png}
 \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer> {Outline}
%    \tableofcontents[currentsection]%,currentsubsection]
    \tableofcontents[sections=\thesection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}



\begin{frame} {Outline}
  	\tableofcontents[hideallsubsections]
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}


% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:  

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\setcounter{framenumber}{\value{framenumber}-1}	%no idea why it otherwise skips one page
\section{Aufgabenstellung}

\begin{frame} {Title}{Subtitle}
	


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {titel}
	
\begin{itemize}[<+->]
	\item<1-> 
	\begin{itemize}[<+->]
		\item<+-> 
		\item<+-> 
		\item<+-> 
		\item<+-> 
	\end{itemize}
	\item<+-> 
\end{itemize}

\note{
	
}
\end{frame}
	
\section{Architektur}

\subsection{Architekturziele}

\begin{frame} {Systemarchitektur}{Anforderungen}
	
	Anforderungen an die Architektur:
	
	\begin{itemize}
	\item inhärent parallel
	\item lose gekoppelte Komponenten
	\item einfache Einbindung externer Bibliotheken
	\item einfache Erweiterbarkeit
	\item Kommunikation über Standardprotokolle
	\end{itemize}
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Überblick}

\begin{frame} {Systemarchitektur}{Überblick}
	
	Die Architektur implementiert ein MVW (Model View Whatever) Modell:
	
	\begin{figure}
		\includegraphics[height=.8\textheight]{images/Architektur.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item Model: Datenbank
			\item View: userInterface
			\item Whatever hier:
			\begin{itemize}
			\item Controller: DataBaseManager
			\item Businnes Logic: searchEngine
			\end{itemize}
		\end{itemize}
	}

\end{frame}

\subsection{Komponenten}

\begin{frame} {Systemarchitektur}{Komponenten}
	
	Es sind insgesamt vier Hauptkomponenten zu erkennen:
	
	\begin{columns}
		\column{0.45\textwidth}
	\begin{itemize}
	\item das UserInterface
	\item der DataBaseManager
	\item die SearchEngine
	\item die Datenbank
	\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/Architektur.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Systemarchitektur}{Kommunikation der Komponenten}
	
	Die Kommunikation der Komponenten findet statt über
	
	\begin{itemize}
	\item HTTP: als Schnittstelle vom UserInterface zum dataBaseManager (REST-API)
	\item Unix-Sockets: zur Interprozesskommunikation zwischen dataBaseManager und searchEngine
	\item HTTP: als Schnittstelle vom dataBaseManager zur Datenbank
	\end{itemize}
	
	Die Schnittstellen sind klar definiert und die Kommunikation findet immer über den dataBaseManager statt.
	
	\skippingparagraph
	Das Datenformat der ausgetauschten Nachrichten ist JSON.
	
	

	\note{
		\begin{itemize}
			\item REST-API: Representational State Transfer: Die Bezeichnung ?Representational State Transfer? soll den Übergang vom aktuellen Zustand zum nächsten Zustand (state) einer Applikation verbildlichen. Dieser Zustandsübergang erfolgt durch den Transfer der Daten, die den nächsten Zustand repräsentieren.
		\end{itemize}
	}

\end{frame}

\subsection{Programmiersysteme}

\begin{frame} {Systemarchitektur}{Auswahl der Programmiersysteme}
	
	Für die Realisierung der einzelnen Komponenten wurden unterschiedliche Technologien verwendet:
	
	\begin{itemize}
	\item C/C++ für die searchEngine
		\begin{itemize}
		\item beste Performance für kritische Datenverarbeitung
		\item gute Parallelisierungsmöglichkeiten für Number Crunching
		\item gute Bibliotheksunterstützung in der Geo-Data Community
		\end{itemize}

	\item HTML/React für das userInterface
		\begin{itemize}
		\item Standard-Webtechnologien zur Realisierung des View
		\item Sehr gute, leicht zu bedienende Darstellungskomponenten
		\item Leichte Erweiterbarkeit und iterative Realisierungsmöglichkeit
		\item Vorwissen für GUI-Realisierung
		\end{itemize}

	\item Node.js/Javascript für den dataBaseManager
		\begin{itemize}
		\item Leichte Integration der Schnittstellen zu anderen Komponenten
		\item Native Unterstützung des JSON-Datenformats
		\item leichtgewichtiger Webserver
		\item sehr gute Unterstützung zum Interfacing der Datenbank
		\end{itemize}
	\end{itemize}
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Parallelität}

\begin{frame} {Systemarchitektur}{Parallelität}
	
	In der vorgestellten Architektur ist Raum für
	\begin{itemize}
	\item grobkörnige Parallelität
		\begin{itemize}
		\item jede vorgestellte Komponente läuft unabhängig von den anderen
		\item Aufteilung auf verschiedene Maschinen möglich
		\item parallele Abarbeitung in mehreren Prozessen auf einer Maschine
		\end{itemize}
	\item feingranulare Parallelität
		\begin{itemize}
		\item die rechenintensive Durchmusterung kann leicht parallelisiert werden
		\item \texttt{pthreads} ist gut geeignet, da gemeinsame Datenbasis genutzt werden kann
		\end{itemize}
	\end{itemize}

	\note{
		\begin{itemize}
		\item durch die verwendeten Protokolle ist Aufteilung auf verschiedene Maschinen möglich
		\end{itemize}
	}

\end{frame}


\section{Komponentenüberblick}
\begin{frame} {Komponentenübersicht}{}
	
Überblick über die Implementierung der einzelnen Komponenten.

	\begin{itemize}
	\item searchEngine mit Durchmusterung
		\begin{itemize}
		\item Überblick über die Datenformate und Vorverarbeitung
		\item Details zum Durchmusterungsalgorithmus und dessen Parallelisierung
		\end{itemize}
	\item dataBaseManager und Datenbank
	\item landingClient als User Interface
	\end{itemize}
	
	Alle Komponenten sollen vorgestellt werden.\\
	Der wichtigste Einzelaspekt ist die Durchmusterung und deren Parallelisierung.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Komponente "`searchEngine"'}

\begin{frame} {Komponente "`searchEngine"'}{Überblick}
	
	Die Komponente searchEngine realisiert die "Geschäftslogik"' der Applikation.\\
	
	Die Komponente ist in zwei Hauptbestandteile aufgeteilt:
	
		\begin{columns}
			\column{0.4\textwidth}
			\begin{itemize}
			\item Datenmanagement und Job Scheduling
			\item Durchmusterung / Number Crunching
			\end{itemize}
	
			\column{0.75\textwidth}
				\begin{figure}
					\includegraphics[width=\textwidth]{images/searchEngine_Komponenten.png}
				\end{figure}
		\end{columns}
	
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`searchEngine"'}{Threading innerhalb der Komponente}
	
	Innerhalb der searchEngine wird exzessiv Gebrauch von Multi-Threading gemacht\\
	\begin{figure}
		\includegraphics[width=\textwidth]{images/searchEngine_Threading.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Datenformate und Verarbeitung}
\begin{frame} {Datenformate und Verarbeitung}{}
	
	Es gibt drei wichtige Datenformate für die Anwendung:
	\begin{itemize}
	\item GeoTIFF
	\item JSON - JavaScript Object Notation
	\item GeoJSON
	\end{itemize}
	
	Kurzer Überblick über die Eigenschaften

	\note{
		\begin{itemize}
			\item Vor der weiteren Betrachtung von Details der Implementierung ist es notwendig
			\item Eigenschaften und Grundlagen der verwendeten Datenformate 
			\item zu erklären
		\end{itemize}
	}

\end{frame}

\subsubsection{GeoTIFF}

\begin{frame} {GeoTIFF}{Überblick -- Grundlagen}
	
	\begin{itemize}
	\item 	GeoTIFF basiert auf TIFF, einem verlustfrei komprimierenden Rasterformat für Bilder.
	\item 	TIFF kann beliebige Größen annehmen.
	\item 	TIFF bietet im Dateiformat die Möglichkeit zu jedem einzelnen Pixel beliebige zusätzliche Informationen zu speichern.
	\end{itemize}
	
	\pause
	
	\begin{itemize}
	\item 	GeoTIFF bindet jedes Pixel eindeutig an einen Koordinatenpunkt auf der Erdoberfläche.
	\item 	Es werden Daten wie Höhe, Temperatur, Bewuchs, \ldots als Informationen in die Pixel kodiert.
	\item 	Enthält entweder Sidecar-Files oder Metadaten mit Informationen zur Projektion. Damit gelingt die eindeutige Zuordnung von Pixeln auf Geo-Koordinaten.
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Beispiel-Datensatz}
	
	Ein Beispiel der hier verwendeten Höhendatensätze:
	
	\only<1>{
		Die Angaben zur Projektion:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.prj}
		
		Die Angaben zur Skalierung:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.tfw}
	}
	
	\only<2>{
	Die Übersicht über das im GeoTIFF erfasste Gebiet.
	\begin{figure}
		\includegraphics[height=0.75\textheight]{images/Gebiet_HH.png}
	\end{figure}
	\smaller{\smaller{Höhen sind als Farbwerte umgesetzt.}}
	}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\subsubsection{Speicherformat: GeoJSON}

\begin{frame} {JSON und GeoJSON}{Überblick}
	
	\begin{columns}
		\column{0.60\textwidth}
		JSON als Datenformat für
		\begin{itemize}
		\item Taskbeschreibungen bei der IPC
		\item Beschreibung gefundener Bahnen über REST-API
		\item GeoJSON zur Speicherung in der Datenbank
		\item GeoJSON zur Darstellung in OpenStreetMap
		\end{itemize}
	
		\column{0.40\textwidth}
			\smaller\smaller\lstinputlisting[style=JSStyle]{snippets/taskDescription.json}
	\end{columns}

	\note{
		\begin{itemize}
			\item Beispiel eines Durchmusterungsauftrags an die searchEngine
		\end{itemize}
	}

\end{frame}


\subsection{GeoTIFFHandler}

\begin{frame} {GeoTIFF-Handler}{vollständige Abstraktion zur Weiterverwendung bei der Durchmusterung}
	
	Die Klasse \texttt{GeoTiffHandler} abstrahiert vollständig von dem zugrundeliegenden Datenformat:
	\begin{itemize}
	\item Durchmusterung rein auf Pixeln
	\item notwendige Metainformationen (Pixelgröße) werden geliefert
	\item Koordinatentransformationen durch Service-Routinen
	\item automatische Speicherverwaltung und (wenn nötig) Kachelung
	\end{itemize}

	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Verarbeitung}
	
	Es ist nicht notwendig die Einlese- und Verarbeitungsroutinen selber zu schreiben.
	
	Es gibt eine OpenSource-Bibliothek \texttt{libtiff}, welche alle Funktionen zur Verfügung stellt.
	
	Weitergehende Bibliothek: \texttt{LargeTiffTools} mit \texttt{tifffastcrop}
	\begin{itemize}
	\item sehr schnelles Einlesen von Teilbildern
	\item es werden nur so viele Daten gelesen wie unbedingt notwendig
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{automatische Kachelung bei kleinem Speicher}
	
	Bestimmung der Einlesegröße nach vorhandenem Speicher:	
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
		\item Aufteilung auf Kacheln, die in den gemeinsamen Speicher passen
		\item Überlappung der Kacheln in den Randbereichen
			\begin{itemize}
			\item Minimum: 1 Mindestlänge der gesuchten Bahn
			\end{itemize}
		\end{itemize}

		\column{0.42\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/UeberlappungKacheln.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame} {GeoTIFF}{Verarbeitung - Koordinatentransformationen}
	
	Zur Einordnung der GeoTIFF Daten auf der Erdoberfläche werden Routinen aus der \texttt{GDAL}-Bibliothek verwendet
	
	\begin{itemize}
	\item \texttt{gdalinfo} als Dienstrogramm zur Abfrage der Metadaten eines GeoTIFF
	\item Umrechnung von Geo-Koordinaten im \texttt{WGS84}-System in Pixel-Koordinaten
	\item Umrechnung von Pixel-Koordinaten in  Geo-Koordinaten im \texttt{WGS84}-System
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item Live-Demo mit \texttt{~/dev/LandingPlanes/terrain gdalinfo "DTM Hamburg 20m.tif" json}
			\item ?GeoTIFF Projections Transform List? listet über 40 verschiedene, offensichtlich gängige Projektionen für GeoTIFF Datensätze auf.
		\end{itemize}
	}

\end{frame}

\subsubsection{Das \texttt{GeoTIFFHandler}-Objekt}

\begin{frame} {\texttt{GeoTiffHandler}}{Datenabstraktion}
	
		\texttt{GeoTiffHandler} liefert für die Durchmusterung zwei wesentliche Datenstrukturen:
		
		\smaller{\lstinputlisting[style=myCStyle]{snippets/datasetInfo.c}}
		
		\smaller{\lstinputlisting[style=myCStyle]{snippets/tilingCharacteristics.c}}
		
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {\texttt{GeoTiffHandler}}{API}
	
		\texttt{GeoTiffHandler} stellt eine einfache API bereit:
		
		\smaller{\lstinputlisting[style=myCStyle]{snippets/geoTiffHandlerAPI.c}}
				
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}




\section{Komponente "'Durchmusterung"'}

\subsection{posix Threads Definition}
\begin{frame} {posix Threads}{Definition - Standard}
	
	Warum Posix Threads?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - POSIX - Portable Operating System Interface\\ 
		\pause - Abstraktion zwischen Hardware und Threading\\
		\pause - erste Standardisierung 1988 (IEEE Std 1003.1-1988)\\
     	\pause - aktuellste Version IEEE Std 1003.1,2016 Edition \\
		\pause - nahezu  alle gängigen OS unterstützem p\_thread\\
	\end{tabular} 


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{posix Threads Umfang}

\begin{frame} {posix Threads}{Standard- was gehört dazu}
	
	Was ist im Standard definiert?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - ca. 100 pthread Funktionen (prefix pthread\_)\\ 
		\pause - Thread Management\\
		\pause - Mutexes\\
		\pause - Condition Variables\\
		\pause - Synchronistation\\
	\end{tabular} 
	\skippingparagraph
	Was ist nicht enthalten?
		\skippingparagraph
	\begin{tabular}{l}
		\pause - Semaphoren\\ 
	\end{tabular} 
	\skippingparagraph
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}
\subsection{Durchmusterung der Geotiff Daten und Auffinden der Landebahnen}

\subsection{Interface der Library}

\subsection{Logischer Ablauf innerhalb der Landebahn-Erkennung}

\subsection{Initialisierung}

\subsection{Parallelverarbeitung mittels p\_threads zum Finden der Landebahnen}

\subsection{Detaillierte Beschreibung des Suchalgorithmus}

\subsection{Klassen und Objekte}

\subsection{Verwendete Datenstrukturen}

\subsubsection{Einfluss der Datenstrukturen auf die Performanz}

\subsection{Bestimmung des Speedups in Abhängigkeit des Parallelisierungsgrades}

\subsubsection{Erläuterung des Messverfahren}

\subsubsection{Messergebnisse}

\subsubsection{Diskussion der Messergebnisse}

\subsection{Analyse mittels Profiler}

\subsection{Einfluss von Compiler Direktiven (speziell Optimizer)}

\section{Komponente "`databaseManager"'}

\begin{frame} {dataBaseManager}{Überblick}
	
	\begin{columns}
		\column{0.5\textwidth}
		Die in einem separaten Prozess ablaufende Komponente \texttt{dataBaseManager} abstrahiert
		\begin{itemize}
		\item alle notwendigen Datenbankzugriffe
		\item einen Controller im MVC-Modell
			\begin{itemize}
			\item nimmt Benutzeranfragen entgegen
			\item verteilt Tasks an die searchEngine
			\item stellt Daten für die View bereit
			\end{itemize}
		\item realisiert einen Merge für Überlappende Landebahnen
		\end{itemize}

		\column{0.55\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/databaseManager_Komponenten.png}
			\end{figure}
	\end{columns}
	

	\note{
		\begin{itemize}
			\item Der Merge ist nicht Kernaufgabe des dataBaseManager, sondern ist hauptsächlich wegen seiner intensiven Datenbankzugriffe hier hinein gekommen.
		\end{itemize}
	}

\end{frame}


\subsection{Datenbankauswahl}

\begin{frame} {Datenbankauswahl}{Warum MongoDB?}

	\begin{tikzpicture}[remember picture,overlay]  
	  \node [xshift=-3.3cm,yshift=-.8cm] at (current page.north east)
	    {\includegraphics[width=4cm]{images/MongoDB_Logo.png}};
	\end{tikzpicture}
	
	Die Wahl der Datenbank fiel auf MongoDB.
	
	Gründe für MongoDB.
	\begin{itemize}
	\item direkte Unterstützung von GeoJSON
	\item ermöglicht \emph{2D-Sphere-Index}-Index
	\item Geospatial Query Operators möglich:
		\begin{itemize}
		\item Alle Landebahnen im Umkreis von x km
		\item Alle Objekte mit Schnittpunkten mit Objekt X
		\item Abfrage Operator \texttt{\$geoIntersects}
		\end{itemize}
	\item gute Unterstützung für parallele Architekturen
	\item sehr gute Unterstützung durch Node.js
	\end{itemize}

	\note{
		\begin{itemize}
			\item parallele Architekturen wie 
			\item sharding
			\item sind aktuell sicherlich sehr gut verzichtbar
		\end{itemize}
	}

\end{frame}




\subsection{Express-Server App}

\begin{frame} {REST-API}{Express-Server}
	
	Die Funktionen des dataBaseManagers werden über eine REST-API per HTTP zur Verfügung gestellt.
	
	Es werden mehrere Endpunkte für HTTP-Requests zur Verfügung gestellt.
	
	\begin{itemize}
		\item GET auf \texttt{/}: HTML-Seite und JavaScript für den Client
		\item POST auf \texttt{/api/fileInfo/}: Dateiinformationen des über einen Dateinamen spezifizierten GeoTIFF
		\item POST auf \texttt{/api/fileInfo/extent}: konvexes Umfangspolygon 
		\item POST auf \texttt{/api/commands/}: Nimmt einen Task entgegen
		\begin{itemize}
			\item \texttt{SCAN}: Durchmustert einen Bereich nach Notlandefeldern. 
			\item \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei
		\end{itemize}
		\item DELETE auf \texttt{/api/commands/drop}: löscht Datenbank
		\item POST auf \texttt{/api/queries/}: liefert Einträge der Datenbank
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Inter Process Communication (IPC)}{Unix-Sockets}
	
	Die dataBaseManagerApp startet eine Instanz der searchEngine in einem eigenen Prozess.
	
	Es wird ein UNIX-Socket geöffnet um bidirektional zwischen den beiden Anwendungen zu kommunizieren.
	
\begin{itemize}
	\item DBM $\rightarrow$ SE \texttt{SCAN}: Durchmusterung eines Datensatzausschnitts. Parameter als JSON.
	\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei.
	\item SE $\rightarrow$ DBM \texttt{landingPlane}: SE hat potentielle Landebahn gefunden. Übergabe von minimaler und maximaler Bahn.
	\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Fertigstellung eines Durchmusterungs-Auftrags. 
\end{itemize}


	\note{
	\begin{itemize}
		\item DBM $\rightarrow$ SE \texttt{SCAN}: Es wird eine Durchmusterung eines Datensatzausschnitts in Auftrag gegeben. Die Parameter werden als JSON durchgereicht.
		\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert einen Bereich eines GeoTIFF Datensatzes in einer Matlab/GNU Octave kompatiblen Textdatei.
		\item SE $\rightarrow$ DBM \texttt{landingPlane}: Die SE hat eine neue potentielle Landebahn gefunden und übergibt sie über ein JSON-Objekt an den DBM um sie in der Datenbank zu persistieren. Für jede gefundene potentielle Bahn werden zwei Objekte übergeben: Die Bahn maximaler Ausdehung, so dass die geforderten Suchkriterien gerade noch eingehalten werden und eine innerhalb dieser Bahn liegende Teilbahn, welche minimale Varianz aufweist und gerade noch die geforderte Mindestlänge erreicht.
		\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Mit einem Task-Receipt meldet die SE dem DBM die Fertigstellung eines Auftrags. Damit kann der DBM nachhalten ob und welche Aufträge noch ausstehen und gegebenenfalls den Client aktiv informieren (Push). Aktuell wird diese Möglichkeit jedoch noch nicht genutzt.
	\end{itemize}
	}

\end{frame}

\subsection{Postprocessing - Merge}

\begin{frame} {Optionales Postprocessing}{Merge-Task}
	
	Es hat sich gezeigt, dass häufig viele nebeneinander liegende Landebahnen gefunden werden, die sich gegenseitig überlappen.
	
	Die Darstellung als einzelne Landebahnen ist unübersichtlich. Daher ist es sinnvoll überlappende Bahnen zusammen zu fassen.
	
		\begin{columns}
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/planesToMerge.png}
				\end{figure}
				
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/mergedPlanes.png}
				\end{figure}
		\end{columns}
		

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Postprocessing}{Merge Proof of concept}
	
	Innerhalb der Quelltextbasis des dataBaseManagers wurde ein unabhängiger Merge-Task implementiert.
	
	Dieser Task läuft vollkommen unabhängig von den anderen Komponenten als reines Postprocessing ab.
	
	\pause
	Der Algorithmus ist sehr einfach gehalten.
	\begin{itemize}
	\item Suche nacheinander alle unbearbeiteten Bahnen aus der DB
	\item für jede gefundene unbearbeitete Bahn:
		\begin{itemize}
		\item Starte DB-Abfrage nach überlappenden Bahnen
		\item Fasse alle überlappenden Bereiche zusammen
		\item Markiere Original-Bahn als Bearbeitet
		\item Lösche kleinere komplexe Polygone aus der DB
		\end{itemize}
	\end{itemize}
	
	\pause
	Aktuell muss dieser Merge-Lauf noch manuell gestartet werden und ist aufgrund der vielen Datenbankzugriffe vergleichsweise langsam.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\section{Komponente "'landingClient"'}

\begin{frame} {Benutzeroberfläche}
	\begin{figure}[ht]
		\includegraphics[width=\textwidth]{../Bericht/drawings/LandingClient_Screen1.png}
		\caption{Beispiel Screenshot aus der Weboberfläche zur Bedienung des Systems}
	\end{figure}
\end{frame}

\subsection{Überblick}

\subsection{Features und Bedienung}

\section{Ausblick und weitere Ideen}

\subsection{Erreichung der Architekturziele}

\begin{frame} {Systemarchitektur}{Architekturziele}
	
	Wurden die Architekturziele erreicht?
	\skippingparagraph
	
	\begin{tabular}{lc}
		\pause inhärent parallel &  \textcolor{green}{\Checkmark}\\ 
		\pause lose gekoppelte Komponenten &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Einbindung externer Bibliotheken &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Erweiterbarkeit &  \textcolor{green}{\Checkmark}\\ 
		\pause Kommunikation über Standardprotokolle &  \textcolor{green}{\Checkmark}
	\end{tabular} 


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}
	
\subsection{Parallele Bearbeitung mehrerer Kacheln per MPI}

\subsection{Richtungskorrektur des GeoTIFF}
\begin{frame} {\texttt{GeoTIFFHandler}}{Implementierungsschwäche}
	
	\begin{columns}
		\column{0.5\textwidth}
	
		Aktuelle Schwäche der Implementierung:
		\begin{itemize}
		\item Aktuelle implizite Annahme: GeoTIFF-Raster ist perfekt nach Süden und Osten ausgerichtet.
		\item Verzerrungen durch Projektion der Kugel in die Ebene ist \emph{nicht} winkeltreu
		\item Richtungsinformationen weichen leicht von Geo-Koordinaten ab. 
		\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/NRW_Extent.png}
			\end{figure}
	\end{columns}


	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}



\subsection{Push für Webclient}

\subsection{Merge als nachgeschalteter Prozess aus dem Speicher}

\subsection{Kollisionsabfrage mit Objekten aus OSM}
	
\end{document}


