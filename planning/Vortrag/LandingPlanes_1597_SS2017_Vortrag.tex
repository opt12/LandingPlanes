 % $Header$

\documentclass[
	xcolor=dvipsnames,
%	handout,
	hideallsubsections,
	xcolor=table
]{beamer} %xcolor=dvipsnames
%\documentclass[xcolor=dvipsnames, handout]{beamer} %xcolor=dvipsnames

\usepackage{pgfpages}

\mode<presentation>
{
	\usetheme{Rochester}
	\usecolortheme{wolverine}
%	\usecolortheme[named=TealBlue]{structure}
%	\usecolortheme[named=Dandelion]{structure}
	
	\setbeamercovered{transparent}
	% or whatever (possibly just delete it)
%	\setbeameroption{show notes} % un-comment to see the notes
	\setbeameroption{show notes on second screen=right}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This LaTeX Beamer file is based on the solution template for:

% - Giving a talk on some subject.
% - The talk is between 15min and 45min long.
% - Style is ornate.

% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thank you so much Till :-)


\usepackage[ngerman]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
 
\input{structure.tex} % Include the structure.tex file which specified the document structure and layout
\usepackage{struktex}

% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\title[Notlandefelder aus Höhendaten] % (optional, use only with long paper titles)
{Erkennung von Notlandefeldern aus Höhendaten: \\
	Parallele Implementierung der Durchmusterung mit \texttt{pThreads}}

\author[] % (optional, use only with lots of authors)
{Felix~Eckstein, Dr. Björn Wittich}
% - Use the \inst{?} command only if the authors have different
%   affiliation.

%\institute[FernUni Hagen] % (optional, but mostly needed)
%{
%}
  
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[] % (optional)
{``1597 -- Fachpraktikum Parallele Programmierung''\\
	im Sommersemester 2017 an der FernUniversität Hagen\\
23. September 2017}

\subject{Talks}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1cm]{university-logo}{images/HannoverJs.png}
  \pgfdeclareimage[height=1cm]{university-logo}{images/UniHagen.png}
 \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer> {Outline}
%    \tableofcontents[currentsection]%,currentsubsection]
    \tableofcontents[sections=\thesection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}



\begin{frame} {Outline}
  	\tableofcontents[hideallsubsections]
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
			\item ACHTUNG: Im folgenden wird häufig das Word "`planes"' verwendet. 
			\item Es ist die Bedeutung im Sinne von "`Ebene"' gemeint.
			\item Das es gleichzeitig auch noch "`Flugzeug"' heißt, ist Zufall
			\item Pun intended!
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}


% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:  

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\setcounter{framenumber}{\value{framenumber}-1}	%no idea why it otherwise skips one page
\section{Aufgabenstellung}

\begin{frame}{Aufgabenstellung}{}
	
	\begin{itemize}[<+->]
		\item<+-> potentielle Notlandebahnen aus Geoterraindaten
		\item<+-> Landebahn definiert über Mindestlänge und - breite
		\item<+-> Akzeptanzktierien Gesamtsteigung, Holprigkeit und Querneigung
		\item<+-> Ausrichtungswinkel der Landebahn (Windrichtung)
		\item<+-> Eingabedaten liegen im GeoTiff Format vor
		\item<+-> Multithreading zur Beschleunigung (p\_threads)
		\item<+-> Analyse des Speedups
	\end{itemize}


	\note{
		\begin{itemize}
         \item bei totalem Triebwerksausfall und kein Flughafen
         \item natürlich unterschiedlich für Ultraleichtflugzeug und A380
         \item Ausrichtungswinkel entscheident bei Windverhältnissen. Seitenwind ungeliebt
         \item TIFF speichert ohne Informationsverlust
         \item POSIX Threads
         \item Laufzeitgewinn gegenüber sequentiellem Lauf
		\end{itemize}
	}

\end{frame}

%\begin{frame} {titel}
	
%\begin{itemize}[<+->]
%	\item<1-> 
%	\begin{itemize}[<+->]
%		\item<+-> 
%		\item<+-> 
%		\item<+-> 
%		\item<+-> 
%	\end{itemize}
%	\item<+-> 
%\end{itemize}

%\note{
	
%}
%\end{frame}
	
\section{Architektur}

\subsection{Architekturziele}

\begin{frame} {Systemarchitektur}{Anforderungen}
	
	Anforderungen an die Architektur:
	
	\begin{itemize}
	\item inhärent und explizit parallel
	\item lose gekoppelte Komponenten
	\item einfache Einbindung externer Bibliotheken
	\item einfache Erweiterbarkeit
	\item Kommunikation über Standardprotokolle
	\end{itemize}
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Überblick}

\begin{frame} {Systemarchitektur}{Überblick}
	
	Die Architektur implementiert ein MVW (Model View Whatever) Modell:
	
	\begin{figure}
		\includegraphics[height=.8\textheight]{images/Architektur.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item Model: Datenbank
			\item View: userInterface
			\item Whatever hier:
			\begin{itemize}
			\item Controller: DataBaseManager
			\item Businnes Logic: searchEngine
			\end{itemize}
		\end{itemize}
	}

\end{frame}

\subsection{Komponenten}

\begin{frame} {Systemarchitektur}{Komponenten}
	
	Es sind insgesamt vier Hauptkomponenten zu erkennen:
	
	\begin{columns}
		\column{0.45\textwidth}
	\begin{itemize}
	\item das UserInterface
	\item der DataBaseManager
	\item die SearchEngine
	\item die Datenbank
	\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/Architektur.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Systemarchitektur}{Kommunikation der Komponenten}
	
	Die Kommunikation der Komponenten findet statt über
	
	\begin{itemize}
	\item HTTP: als Schnittstelle vom UserInterface zum dataBaseManager (REST-API)
	\item Unix-Sockets: zur Interprozesskommunikation zwischen dataBaseManager und searchEngine
	\item HTTP: als Schnittstelle vom dataBaseManager zur Datenbank
	\end{itemize}
	
	Die Schnittstellen sind klar definiert und die Kommunikation findet immer über den dataBaseManager statt.
	
	\skippingparagraph
	Das Datenformat der ausgetauschten Nachrichten ist JSON.
	
	

	\note{
		\begin{itemize}
			\item REST-API: Representational State Transfer: Die Bezeichnung ?Representational State Transfer? soll den Übergang vom aktuellen Zustand zum nächsten Zustand (state) einer Applikation verbildlichen. Dieser Zustandsübergang erfolgt durch den Transfer der Daten, die den nächsten Zustand repräsentieren.
		\end{itemize}
	}

\end{frame}

\subsection{Programmiersysteme}

\begin{frame} {Systemarchitektur}{Auswahl der Programmiersysteme}
	
	Für die Realisierung der einzelnen Komponenten wurden unterschiedliche Technologien verwendet:
	
	\begin{itemize}
	\item C/C++ für die searchEngine
		\begin{itemize}
		\item beste Performance für kritische Datenverarbeitung
		\item gute Parallelisierungsmöglichkeiten für Number Crunching
		\item gute Bibliotheksunterstützung in der Geo-Data Community
		\end{itemize}
	
	\pause
	\item HTML/React für das userInterface
		\begin{itemize}
		\item Standard-Webtechnologien zur Realisierung des View
		\item Sehr gute, leicht zu bedienende Darstellungskomponenten
		\item Leichte Erweiterbarkeit und iterative Realisierungsmöglichkeit
		\item Vorwissen für GUI-Realisierung
		\end{itemize}

	\pause
	\item Node.js/Javascript für den dataBaseManager
		\begin{itemize}
		\item Leichte Integration der Schnittstellen zu anderen Komponenten
		\item Native Unterstützung des JSON-Datenformats
		\item leichtgewichtiger Webserver
		\item sehr gute Unterstützung zum Interfacing der Datenbank
		\end{itemize}
	\end{itemize}
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Parallelität}

\begin{frame} {Systemarchitektur}{Parallelität}
	
	In der vorgestellten Architektur ist Raum für
	\begin{itemize}
	\item grobkörnige Parallelität
		\begin{itemize}
		\item jede vorgestellte Komponente läuft unabhängig von den anderen
		\item Aufteilung auf verschiedene Maschinen möglich
		\item parallele Abarbeitung in mehreren Prozessen auf einer Maschine
		\end{itemize}
	\item feingranulare Parallelität
		\begin{itemize}
		\item die rechenintensive Durchmusterung kann leicht parallelisiert werden
		\item \texttt{pthreads} ist gut geeignet, da gemeinsame Datenbasis genutzt werden kann
		\end{itemize}
	\end{itemize}

	\note{
		\begin{itemize}
		\item durch die verwendeten Protokolle ist Aufteilung auf verschiedene Maschinen möglich
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponentenübersicht}{}
	
Überblick über die Implementierung der einzelnen Komponenten.

	\begin{itemize}
	\item searchEngine mit Durchmusterung
		\begin{itemize}
		\item Überblick über die Datenformate und Vorverarbeitung
		\item Details zum Durchmusterungsalgorithmus und dessen Parallelisierung
		\end{itemize}
	\item dataBaseManager und Datenbank
	\item landingClient als User Interface
	\end{itemize}
	
	Alle Komponenten sollen vorgestellt werden.\\
	Der wichtigste Einzelaspekt ist die Durchmusterung und deren Parallelisierung.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\section{Komponente "`searchEngine"'}


\subsection{Überblick}

\begin{frame} {Komponente "`searchEngine"'}{Überblick}
	
	Die Komponente searchEngine realisiert die "Geschäftslogik"' der Applikation.\\
	
	Die Komponente ist in zwei Hauptbestandteile aufgeteilt:
	
		\begin{columns}
			\column{0.4\textwidth}
			\begin{itemize}
			\item Datenmanagement und Job Scheduling
			\item Durchmusterung / Number Crunching
			\end{itemize}
	
			\column{0.75\textwidth}
				\begin{figure}
					\includegraphics[width=\textwidth]{images/searchEngine_Komponenten.png}
				\end{figure}
		\end{columns}
	
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`searchEngine"'}{Threading innerhalb der Komponente}
	
	Innerhalb der searchEngine wird exzessiv Gebrauch von Multi-Threading gemacht\\
	\begin{figure}
		\includegraphics[width=\textwidth]{images/searchEngine_Threading.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Datenformate und Verarbeitung}
\begin{frame} {Datenformate und Verarbeitung}{}
	
	Es gibt drei wichtige Datenformate für die Anwendung:
	\begin{itemize}
	\item GeoTIFF
	\item JSON - JavaScript Object Notation
	\item GeoJSON
	\end{itemize}
	
%	Kurzer Überblick über die Eigenschaften

	\note{
		\begin{itemize}
			\item Vor der weiteren Betrachtung von Details der Implementierung ist es notwendig
			\item Eigenschaften und Grundlagen der verwendeten Datenformate 
			\item zu erklären
		\end{itemize}
	}

\end{frame}

\subsubsection{GeoTIFF}

\begin{frame} {GeoTIFF}{Überblick -- Grundlagen}
	
	\begin{itemize}
	\item 	GeoTIFF basiert auf TIFF, einem verlustfrei komprimierenden Rasterformat für Bilder.
	\item 	TIFF kann beliebige Größen annehmen.
	\item 	TIFF bietet im Dateiformat die Möglichkeit zu jedem einzelnen Pixel beliebige zusätzliche Informationen zu speichern.
	\end{itemize}
	
	\pause
	
	\begin{itemize}
	\item 	GeoTIFF bindet jedes Pixel eindeutig an einen Koordinatenpunkt auf der Erdoberfläche.
	\item 	Es werden Daten wie Höhe, Temperatur, Bewuchs, \ldots als Informationen in die Pixel kodiert.
	\item 	Enthält entweder Sidecar-Files oder Metadaten mit Informationen zur Projektion. Damit gelingt die eindeutige Zuordnung von Pixeln auf Geo-Koordinaten.
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Beispiel-Datensatz}
	
	Ein Beispiel der hier verwendeten Höhendatensätze:
	
	\only<1>{
		Die Angaben zur Projektion:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.prj}
		
		Die Angaben zur Skalierung:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.tfw}
	}
	
	\only<2>{
	Die Übersicht über das im GeoTIFF erfasste Gebiet.
	\begin{figure}
		\includegraphics[height=0.75\textheight]{images/Gebiet_HH.png}
	\end{figure}
	\smaller{\smaller{Höhen sind als Farbwerte umgesetzt.}}
	}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\subsubsection{Speicherformat: GeoJSON}

\begin{frame} {JSON und GeoJSON}{Überblick}
	
	\begin{columns}
		\column{0.60\textwidth}
		JSON als Datenformat für
		\begin{itemize}
		\item Taskbeschreibungen bei der IPC
		\item Beschreibung gefundener Bahnen über REST-API
		\item GeoJSON zur Speicherung in der Datenbank
		\item GeoJSON zur Darstellung in OpenStreetMap
		\end{itemize}
	
		\column{0.40\textwidth}
			\smaller\smaller\lstinputlisting[style=JSStyle]{snippets/taskDescription.json}
	\end{columns}

	\note{
		\begin{itemize}
			\item Beispiel eines Durchmusterungsauftrags an die searchEngine
		\end{itemize}
	}

\end{frame}


\subsection{GeoTIFFHandler}

\begin{frame} {GeoTIFF-Handler}{vollständige Abstraktion zur Weiterverwendung bei der Durchmusterung}
	
	Die Klasse \texttt{GeoTiffHandler} abstrahiert vollständig von dem zugrundeliegenden Datenformat:
	\begin{itemize}
	\item Durchmusterung rein auf Pixeln
	\item notwendige Metainformationen (Pixelgröße) werden geliefert
	\item Koordinatentransformationen durch Service-Routinen
	\item automatische Speicherverwaltung und (wenn nötig) Kachelung
	\end{itemize}

	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Verarbeitung}
	
	Es ist nicht notwendig die Einlese- und Verarbeitungsroutinen selber zu schreiben.
	
	Es gibt eine OpenSource-Bibliothek \texttt{libtiff}, welche alle Funktionen zur Verfügung stellt.
	
	Weitergehende Bibliothek: \texttt{LargeTiffTools} mit \texttt{tifffastcrop}
	\begin{itemize}
	\item sehr schnelles Einlesen von Teilbildern
	\item es werden nur so viele Daten gelesen wie unbedingt notwendig
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{automatische Kachelung bei kleinem Speicher}
	
	Bestimmung der Einlesegröße nach vorhandenem Speicher:	
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
		\item Aufteilung auf Kacheln, die in den gemeinsamen Speicher passen
		\item Überlappung der Kacheln in den Randbereichen
			\begin{itemize}
			\item Minimum: 1 Mindestlänge der gesuchten Bahn
			\end{itemize}
		\end{itemize}

		\column{0.42\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/UeberlappungKacheln.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame} {GeoTIFF}{Verarbeitung - Koordinatentransformationen}
	
	Zur Einordnung der GeoTIFF Daten auf der Erdoberfläche werden Routinen aus der \texttt{GDAL}-Bibliothek verwendet
	
	\begin{itemize}
	\item \texttt{gdalinfo} als Dienstrogramm zur Abfrage der Metadaten eines GeoTIFF
	\item Umrechnung von Geo-Koordinaten im \texttt{WGS84}-System in Pixel-Koordinaten
	\item Umrechnung von Pixel-Koordinaten in  Geo-Koordinaten in das \texttt{WGS84}-System
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item Live-Demo mit \texttt{~/dev/LandingPlanes/terrain gdalinfo "DTM Hamburg 20m.tif" json}
			\item ?GeoTIFF Projections Transform List? listet über 40 verschiedene, offensichtlich gängige Projektionen für GeoTIFF Datensätze auf.
		\end{itemize}
	}

\end{frame}

\subsubsection{Das \texttt{GeoTIFFHandler}-Objekt}

\begin{frame} {\texttt{GeoTiffHandler}}{Datenabstraktion}
	
		\texttt{GeoTiffHandler} liefert für die Durchmusterung zwei wesentliche Datenstrukturen:
		
		{\smaller{\lstinputlisting[style=myCStyle]{snippets/datasetInfo.c}}}
		

		{\smaller{\lstinputlisting[style=myCStyle]{snippets/tilingCharacteristics.c}}}
		
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {\texttt{GeoTiffHandler}}{API}
	
		\texttt{GeoTiffHandler} stellt eine einfache API bereit:
		
		\smaller{\lstinputlisting[style=myCStyle]{snippets/geoTiffHandlerAPI.c}}
				
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}




\section{Komponente "'Durchmusterung"'}

\subsection{Durchmusterung der Geotiff Daten und Auffinden der Landebahnen}
\begin{frame} {Übersicht}{Ziele der Entwicklung}

\begin{itemize}
	\item  Kapselung der Suchlogik 
	\item  beinhaltet domänenspezifische Anforderungen
	\item  Objektorientierter Ansatz zur besseren Wartbarkeit
	\item  Komponente wird in Form einer statischen Library (aus)geliefert
\end{itemize}

	\note{
		\begin{itemize}
			\item Kapselung wichtig für Wartung und Erweiterbarkeit
			\item zentralisierte Behandlung der Requirements
			\item leichtes benutzen an anderer Stelle
			\item sicherlich noch ausbaufähig
		\end{itemize}
	}

\end{frame}


\subsection{Interface der Library}
\begin{frame} {Interface der Library}{Definition}

\lstinputlisting[style=myCStyle]{snippets/Durchmusterungslibrary.c}


\begin{tabular}{ll}
 *actualTile & Zeiger auf das Geo-Kartenobjekt\\
 *myGeoTiffHandler & Zeiger auf GeoTiffHandler mit Hilfsfunktionen\\
 heading & Suchwinkel\\
 minLength & Mindestlänge in [m]\\
 width & Breite in [m]\\
 commSocket & Socket für Mongo DB Kommunikation\\
 *taskDescription & Taskbeschreibung\\
 noDataValue & Zahlenwert für undefinierte Kartenpunkte\\
 pixelSize & Auflösung der Rasterpunkte in [m]\\
 \end{tabular}  
 	\note{
		\begin{itemize}
			\item nicht Wundern: Größe wie vertikale und horizontale kurzreichweitige sowie Gesamtsteigung Steigung in der Taskdeskription als Parameter
			\item ist etwas unsauber, könnte man leicht ändern
			\item natürlich könnte die Komponente auch selbst lernen, Geodaten einzulesen. Aber dann wäre sie zu mächtig
			\item ebenso mit dem GeoTiffHandler
			\item Socket für Mongo DB wird übergeben. Identifizierung des Suchlaufs über Taskdescription
			\item noDataValue beschreibt sozusagen den Wert für NULL
		\end{itemize}
	} 
\end{frame}

\subsection{Logischer Ablauf innerhalb der Landebahn-Erkennung}
\begin{frame}{Landebahnbestimmung}{Durchmusterungsalgorithmus in Pseudo-Code}
\begin{figure}
\scalebox{.41}{\begin{struktogramm}(200,150)
  \assign{Initialisierung $tile\_worker$ Objekt}
  \assign{berechne winkel-, steigungs- und holprigkeitsabhängige Parameter}
\forallin{für alle Startpunkte einer Landebahn in gegebener Richtung (Thread Pool)}
\assign{wähle den nächsten Punkt}
\ifthenelse[15]{1}{1}
{kurzreichweitige Steigung zum Vorgänger OK?}{\sTrue}{\sFalse}
\ifthenelse[17]{2}{6}
{checke Holprigkeit in Querrichtung}{\sTrue}{\sFalse}
\change
\ifthenelse[40]{1}{1}
{ist die aktuelle Landebahn länger als die Mindestlänge}{\sTrue}{\sFalse}
\assign{suche die beste Landebahn mit Mindestlänge}
\assign{speichere beide Landebahnen in der DB}
%\assign{starte eine neue Landebahn mit aktuellem Punkt}
\change
%\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\change
\ifthenelse[30]{1}{1}
{ist die aktuelle Landebahn länger als die Mindestlänge}{\sTrue}{\sFalse}
\assign{suche die beste Landebahn mit Mindestlänge}
\assign{speichere beide Landebahnen in der DB}
%\assign{starte eine neue Landebahn mit aktuellem Punkt}
\change
%\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\forallinend
\end{struktogramm}}
\label{nasshnlogisch}
\caption{Nassi-Shneiderman-Diagramm der Suchstrategie}
\end{figure}
 	\note{
		\begin{itemize}
			\item TileWorkerObjekt ist nicht der Thread Worker, sondern ist assoziert zu dem übergebenen Kachelobjekt
			\item Schleife soll andeuten, wo hier Threadpool ins Spiel kommt
			
		\end{itemize}
	} 
\end{frame}

\subsection*{Initialisierung}
\begin{frame}{Landebahnbestimmung}{logischer Ablauf}
	\begin{tabular}{l}
		\pause - Instanziierung Workerobjekt\\ 
		\pause - Initialisierung von Schrittvektoren (winkelabhängig)\\
		\pause - Initialisierung von orthogonalen Schrittvektoren (Breite)\\
     	\pause - Bestimmung des Startpunktes zur Durchmusterung\\
		\pause - Bestimmung Anzahl zusammenhängender Punkte einer validen Bahn\\
	\end{tabular} 
	 	\note{
		\begin{itemize}
			\item Wie schon erwähnt das Workerobjekt hängt an der übergebenen Kachel, nicht am Thread
			\item Beim Startpunkt geht es darum, sicherzustellen, dass die gesamte Kachel auch wirklich in vorgegebener Richtung durchmustert wird
			\item bei konstanten Punktabständen kann man genau festlegen, wie viele zusammenhängende Punkte benötigt werden, damit die Längen- und Breitendimension passt. Das erspart ständige Entfernungsberechnungen
			
		\end{itemize}
	} 
\end{frame}

\subsection{systematisches Durchlaufen der Geodaten}
\begin{frame}{Startpunkte der Bahnen}{freier Winkel}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};
\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (4,5)--(5,4) node[left]{$1$};
\draw[->,ultra thick,dashed,red] (3,5)--(5,3) node[left]{$2$};
\draw[->,ultra thick,dashed,red] (0,5)--(5,0) node[right]{$3$};

\draw[->,ultra thick,dashed,red] (0,3)--(3,0) node[below]{$4$};

\draw[->,ultra thick,dashed,red] (0,1)--(1,0) node[below]{$5$};

\draw[-,ultra thick,dashed,blue] (5,5.5)--(-0.5,5.5) node[left]{};
\draw[->,ultra thick,dashed,blue] (-0.5,5.5)--(-0.5,0) node[left]{};
\end{tikzpicture}
\end{figure}
	 	\note{
		\begin{itemize}
			\item blauer Vektor zeigt sozusagen die Wanderung des Startpunktes
			\item man erkennt, dass die Durchmusterungsstrecken nicht gleich lang sind
			\item von Bahn 1 bis 3 zunehmende Länge, von 3 - 5 wieder abnehmende Längen
			\item unterschiedlich lange Laufzeit (hängt natürlich noch davon ab, wie viele Cluster gefunden werden, in denen ideale Bahnen gefunden werden)
			
			
		\end{itemize}
	} 
\end{frame}

%\subsection{Durchmusterung}
\begin{frame}{Startpunkte der Bahnen}{orthogonales System}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};

\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (0,5)--(0,0) node[below]{$1$};
\draw[->,ultra thick,dashed,red] (1,5)--(1,0) node[below]{$2$};
\draw[->,ultra thick,dashed,red] (3,5)--(3,0) node[below]{$3$};
\draw[->,ultra thick,dashed,red] (5,5)--(5,0) node[below]{$4$};


\draw[->,ultra thick,dashed,blue] (-0,5.5)--(5,5.5) node[left]{};
\end{tikzpicture}
\end{figure}
	 	\note{
		\begin{itemize}
			\item blauer Vektor zeigt auch hier die Wanderung
			 \item nur an einer Seite
			 \item alle Strecken gleichlang
			\item unterschiedlich lange Laufzeit trotzdem möglich (hängt natürlich noch davon ab, wie viele Cluster gefunden werden, in denen ideale Bahnen gefunden werden)
			
		\end{itemize}
	} 
\end{frame}

\subsection{posix Threads Definition}
\begin{frame} {posix Threads}{Definition - Standard}
	
	Warum Posix Threads?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - POSIX - Portable Operating System Interface\\ 
		\pause - Abstraktionschicht zwischen Hardware und Software\\ 
		         (insbesondere für Threading)\\
		\pause - erste Standardisierung 1988 (IEEE Std 1003.1-1988)\\
     	\pause - aktuellste Version IEEE Std 1003.1,2016 Edition \\
		\pause - nahezu  alle gängigen OS unterstützem p\_thread\\
	\end{tabular} 


	\note{
		\begin{itemize}
			\item Ausführungsmodell ist unabhängig von einer Sprache, allerdings C / C++ am bekanntesten.
			\item Erlaubt überlappende Programmausführung
			\item Entstehung ist historisch bedingt. In den Anfangszeiten haben Hardwarehersteller eigene Lösungen bereitgestellt, die aber stark unterschiedlich waren. Es war kaum möglich, portierbare Software zu entwickeln.
			\item heute stellen die Hardwarehersteller zusätzlich zu properitären Lösungen pthread zur Verfügung
			\item Vorteil: Thread Erzeugung ca. 10 - 100 Mal schneller als Prozess zu forken
			\item natürlich nicht Windows bzw. nicht nativ, aber es gibt  Pthreads-w32 und mingw als add on support
		\end{itemize}
	}

\end{frame}

\subsection*{posix Threads Umfang}

\begin{frame} {posix Threads}{Standard - was gehört dazu}
	
	Was ist im Standard definiert?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - ca. 100 pthread Funktionen (prefix pthread\_)\\ 
		\pause - Thread Management\\
		\pause - Mutexes\\
		\pause - Condition Variables\\
		\pause - Synchronistation\\
	\end{tabular} 
	\skippingparagraph
	\pause Was ist nicht enthalten?
		\skippingparagraph
	\begin{tabular}{l}
		\pause - Semaphoren\\ 
	\end{tabular} 
	\skippingparagraph
	
	\note{
		\begin{itemize}
			\item typisch: pthread\_create, pthread\_exit, pthread\_cancel, pthread\_join , pthread\_detach
			\item mutex: pthread\_mutex\_init, pthread\_mutex\_destroy, pthread\_mutex\_lock, pthread\_mutex\_trylock, pthread\_mutex\_unlock 
			\item condition variables: pthread\_cond\_init, pthread\_cond\_destroy, werden benutzt um Threadverhalten in Datenabhängigkeit zu steuern (ohne teures Polling)
			\item Empfehlung: Kurs 01727 Mitautor anwesend 
			\item was nicht inbegriffen sind Semaphoren. Eine Art Mutex, die allerdings einen Zähler beinhaltet. Mutex ist quasi ein binäres Semaphor
		\end{itemize}
	}

\end{frame}

\subsection{Parallelverarbeitung mittels p\_threads zum Finden der Landebahnen}
\begin{frame}{Programmiermodlle mit Threads}{}
\pause $\Rightarrow$ Master -  Worker / Slave
	
\pause $\Rightarrow$ Peer
	
\pause $\Rightarrow$ Pipeline
	
\pause $\Rightarrow$ Thread-Pool
			\skippingparagraph
		\begin{tabular}{l}
		\pause - Ressourcenschonend\\
		 \pause - identische Initialisierung\\
		  \pause - ideal zur Performanz-Untersuchung\\
	\end{tabular} 
	\skippingparagraph
	Gesteuert via Semaphor
	
		\note{
		\begin{itemize}
			\item Master / worker: Alle Aufgaben werden an einen neuen Thread vergeben. Master hat Kontrolle
			\item Peer: Master hat keinen Einfluss mehr. Nicht geblockt. Thread Gruppe arbeitet eigenständig ab
			\item Pipeline: Stufenweises abarbeiten. Jede Stufe ein Thread
			\item Thread-Pool: ähnlich Master - Worker, aber ein Pool von Threads die nacheinander Aufgaben beim master abholen.
		\end{itemize}
	}
\end{frame}

\begin{frame}{Paralleles Suchen der Landebahnen}{Thread-Pool}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};
\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (4,5)--(5,4) node[left]{$1$};
\draw[->,ultra thick,dashed,red] (3,5)--(5,3) node[left]{$2$};
\draw[->,ultra thick,dashed,red] (0,5)--(5,0) node[right]{$3$};

\draw[->,ultra thick,dashed,red] (0,3)--(3,0) node[below]{$4$};

\draw[->,ultra thick,dashed,red] (0,1)--(1,0) node[below]{$5$};

\draw[-,ultra thick,dashed,blue] (5,5.5)--(-0.5,5.5) node[left]{};
\draw[->,ultra thick,dashed,blue] (-0.5,5.5)--(-0.5,0) node[left]{};


\end{tikzpicture}
\end{figure}

		\begin{itemize}
			\item blaue Linie entspricht dem Master
			\item rot sind die unabhängigen Threads des Pools
		\end{itemize}
		\note{
		\begin{itemize}
			\item blaue Linie entspricht dem Master
			\item rot sind die unabhängigen Threads des Pools
			\item Herausgabe neuer Startpunkte ist über ein Mutex synchronisiert
		\end{itemize}
	}
\end{frame}

\subsection{Detaillierte Beschreibung des Suchalgorithmus}
\begin{frame}{Detaillierte Beschreibung des Suchalgorithmus}{Vorclustern}
	\begin{tabular}{l}
		\pause - hat der aktuelle Punkt gültige Höheninformationen?\\
		\pause - ist die Steigung zu seinem Vorgänger OK? (Holprigkeit)\\
		\pause - sind innerhalb von $\frac{1}{2}B$ in orthogonaler Richtung die Steigungen OK?\\
		\pause - ist die Holprigkeit aller orthogonaler Punkte gültig?\\
	\end{tabular} 
	\skippingparagraph
   \pause Sind alle diese Punkte erfüllt, wird der Punkt in eine Liste aufgenommen
    
    Dies wird so lange wiederholt, bis 
    		\begin{itemize}
			\item der Kartenrand erreicht ist
			\item oder ein Punkt diese Kriterien nicht erfüllt
		\end{itemize}

 \end{frame}
 
%\subsection{Detaillierte Beschreibung des Suchalgorithmus}
\begin{frame}{Detaillierte Beschreibung des Suchalgorithmus}{Optimierung innerhalb des Clusters}


    Sind alle diese Punkte erfüllt, werden zwei Landebahnen bestimmt:
   	\skippingparagraph 
	\begin{tabular}{l}
		\pause - die längstmögliche, die die max. Steigung nicht überschreitet\\
		\pause - die (Sub)Fläche mit der kleinsten Varianz über alle Punkte\\
	\end{tabular} 
		\skippingparagraph
	Die beiden gefundenen Bahnen werden in der Mongo-DB abgelegt
        		\note{
		\begin{itemize}
			\item es kann vorkommen, dass es innerhalb der Fläche keine valide Bahn gibt
			\item z.B. Holprigkeit ist immer kurz unter dem Limit, damit ist die Gesamtsteigung dann plötzlich zu groß
			
		\end{itemize}
	}
 \end{frame}
 
 
 
\subsection{Verwendete Datenstrukturen - Performanz}
\begin{frame}{Verwendete Datenstrukturen}{Performanz}
Augenmerk lag auf der Verwendung von wenig komplexen Datenstrukturen und Funktionen


	\begin{tabular}{ll}
	
		\pause - \tiny\texttt{vector< pair<int,int> >} & \tiny Referenz auf die Kartenpunkte\\
		\pause - \tiny\texttt{int access\_single\_element(int\ x, int\ y)}&\tiny mapping 2D $\rightarrow$ 1D\\
	\end{tabular} 
	
   	\skippingparagraph 	

Außer dem Allokieren des Vektorspeichers sind die Operationen der Hauptschleife unabhängig von $n$
	
	        		\note{
		\begin{itemize}
			\item Eigentlich weitergefasst. Nicht nur Datenstrukturen, sondern Komplexität bei den Routinen der Hauptschleifen
			\item Vektor ist random access Zugriff und unabhängig zur Größe. Außer der Allokator, je nachdem, wie man einfügt.
			\item Kartenpunkte werden als 1 Dim Array übergeben. Die Berechnung der Position aus 2D Koordinaten ist unabhängig von Größe der Datenmenge
			
		\end{itemize}
	}
\end{frame}

\subsection{Erläuterung des Messverfahren}
\begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{Messverfahren}
    		\begin{itemize}
			\item innerhalb VM (Virtualbox)
			\item Host:  Intel i7-4770K , 3.5 Ghz, 16 GB RAM Windows 7 64 bit
			\item Guest: Centos Linux 7.0, 6 GB RAM
			\item Variation der virtuellen CPUs des Guest Systems
			\item Poolgröße über das UI vorgegeben
			\item pro Parameterset 4 unabhängige Läufe (Mittelwert + Standardabweichung)
			
		\end{itemize}
 	        		\note{
		\begin{itemize}
			\item natürlich interessant ist die Laufzeit: sowohl sequentiell als auch parallel
			\item Messungen innerhalb einer VM 
			\item Variation der CPUs der VM
			\item CPU Modell aus dem Jahr 2013 also schon alt
			\item 4 Kerne 
			
		\end{itemize}
	}
\end{frame}
 

\subsection{Bestimmung des Speedups in Abhängigkeit des Parallelisierungsgrades}
\begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{Messergebnisse 1 vCPU}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  1 & 1 & \cellcolor{red!25}  11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  2 & 1 & \cellcolor{red!25}  11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  4 & 1 & \cellcolor{red!25} 11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  8 & 1 & \cellcolor{red!25}  11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  64 & 1 & \cellcolor{red!25}  10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 2 & 5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 4 & 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 4 & 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
     		\note{
		\begin{itemize}
			\item zunächst 1 CPU für VM
			\item CPU wird zwischen unserer Software und Guest OS geteilt
			\item zu viele threads schaden aber bislang auch nicht
			
		\end{itemize}
	}
 \end{frame}
 
 \begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{Messergebnisse 2 vCPU}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 1 & 2 & \cellcolor{red!25} 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 2 & 2 & \cellcolor{red!25} 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &\cellcolor{red!25}  4 & 2 & \cellcolor{red!25} 5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 4 & 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 4 & 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
     		\note{
		\begin{itemize}
			\item interessant: Speedup schon im seriellen Betrieb
			\item Grund wohl: relative Anteil des OS nimmt ab
			\item 2 fach parallel hat schon einen Speedup
			
		\end{itemize}
	}
 \end{frame}
 
 \begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{Messergebnisse 4 vCPU}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 2 &  5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 1 & 4 & \cellcolor{red!25} 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 2 & 4 & \cellcolor{red!25} 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 4 & 4 & \cellcolor{red!25} 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 8 & 4 & \cellcolor{red!25} 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
     		\note{
		\begin{itemize}
			\item hier wird schon der overhead sichtbar. Auch der master brauch ja Rechenzeit, um den Startpunkt zu verschieben
			
		\end{itemize}
	}
 \end{frame}
 
 
  \begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{Messergebnisse 8 vCPU}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 2 &  5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 4 &  8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 4 &  4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 16 & 8 & \cellcolor{red!25} 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}

8 CPUs eventuell nicht verwertbar, da VM Software Warnung anzeigte.
     		\note{
		\begin{itemize}
			\item hier keine zuverlässige Aussage mehr möglich. VM Host zeigte Warnung an
		\end{itemize}
	}
 \end{frame}


\subsubsection{Diskussion der Messergebnisse}
\begin{frame}{Speedup in Abhängigkeit des Parallelisierungsgrades}{visuelle Darstellung}
\begin{tikzpicture} 
\begin{axis}[ 
  xlabel=Anzahl CPU, ylabel=Speedup, legend style={at={(axis cs:8.3,1)},anchor=south east}] 
  \addplot[color=red,mark=x] coordinates { 
  (1,1) 
  (2,2.11) 
  (4,3.84) 
  (8,4.2)   
  }; 
    \addplot[color=blue,mark=x] coordinates { 
  (1,1) 
  (2,1.8) 
  (4,3.13)    
  }; 
    \addplot[color=green,mark=x] coordinates { 
  (1,1) 
  (2,2.02) 
  (4,3.35)    
  }; 
    \addlegendentry{Nord-Süd}
  \addlegendentry{Ost-West}
    \addlegendentry{Nordnordwest-Südsüdost}
  \end{axis} 

  \end{tikzpicture}
  
       		\note{
		\begin{itemize}
			\item Speedup skaliert anfangs gut
			\item ab einem gewissen Punkt wird er kleiner
			\item ab einem gewissen Punkt dominieren die Varianzberechungen 
			\item außerdem stehen dich die Threads bei den kurzen Bahnen am Ende in den "Füßen rum"
		\end{itemize}
	}
\end{frame}

\subsection{Analyse mittels Profiler}
\begin{frame}{Laufzeitanalyse mittels Profiler}

    		\begin{itemize}
    		\item Laufzeitanalyse mittels gproof
    		\item größter Laufzeitanteil für die Zugriffsfunktion (Random Memory access)
    		\item zweitgrößter Anteil ist die Bestimmung der varianzminimalen Landebahn
    		\item intuitiv so zu erwarten
    		\item Potential für inneres Threading beim Auffinden der Landebahn
    		\end{itemize}
    		
    		       		\note{
		\begin{itemize}
			\item gproof erzeugt   während des Laufes eine Statistik, die man später ansehen kann
			\item interessant für Performanceverbesserungen
			
		\end{itemize}
	}

\end{frame}
\subsection{Einfluss von Compiler Direktiven (speziell Optimizer)}
\begin{frame}{Einfluss des Optimizers}

    		\begin{itemize}
    		\item redhat devtoolset 4
    		\item gcc / g++ Version 4.8.5
    		\item -O3 Direktiv aktiviert Optimizer 
    		\end{itemize}
    		
    	\note{
		\begin{itemize}
			\item gproof erzeugt   während des Laufes eine Statistik, die man später ansehen kann
			\item interessant für Performanceverbesserungen
			
		\end{itemize}
	}
\end{frame}
\begin{frame}{Einfluss des Optimizers}

    		\begin{itemize}
    		\item redhat devtoolset 4
    		\item gcc / g++ Version 4.8.5
    		\item -O3 Direktiv aktiviert Optimizer 
    		\end{itemize}
    		
    		  	\skippingparagraph 
    		  		\begin{itemize}
    		  		\item  Beschleunigung der Codeausführung\\ 
    		  		     um 1300~\% (11 s vs. 147 s)
    		  		\end{itemize}
    	\note{
		\begin{itemize}
			\item Optimizer hat großen Einfluss
			\item z.B. toten Code entfernen
			\item multiple statische Operationen zusammenfassen
			\item Schleifenoptimierung (herausziehen von Konstanten)
			\item Zielmaschinenbefehlssatz ausnutzen (bitshift statt diivsion durch 2)
			
			
		\end{itemize}
	}
\end{frame}
\section{Komponente "`databaseManager"'}

\begin{frame} {dataBaseManager}{Überblick}
	
	\begin{columns}
		\column{0.6\textwidth}
		Die in einem separaten Prozess ablaufende Komponente \texttt{dataBaseManager} abstrahiert
		\begin{itemize}
		\item alle notwendigen Datenbankzugriffe
		\item einen Controller im MVC-Modell
			\begin{itemize}
			\item nimmt Benutzeranfragen entgegen
			\item verteilt Tasks an die searchEngine
			\item stellt Daten für die View bereit
			\end{itemize}
		\item realisiert einen Merge für Überlappende Landebahnen
		\end{itemize}

		\column{0.45\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/databaseManager_Komponenten.png}
			\end{figure}
	\end{columns}
	

	\note{
		\begin{itemize}
			\item Der Merge ist nicht Kernaufgabe des dataBaseManager, sondern ist hauptsächlich wegen seiner intensiven Datenbankzugriffe hier hinein gekommen.
		\end{itemize}
	}

\end{frame}


\subsection{Datenbankauswahl}

\begin{frame} {Datenbankauswahl}{Warum MongoDB?}

	\begin{tikzpicture}[remember picture,overlay]  
	  \node [xshift=-3.3cm,yshift=-.8cm] at (current page.north east)
	    {\includegraphics[width=4cm]{images/MongoDB_Logo.png}};
	\end{tikzpicture}
	
	Die Wahl der Datenbank fiel auf MongoDB.
	
	Gründe für MongoDB.
	\begin{itemize}
	\item direkte Unterstützung von GeoJSON
	\item ermöglicht \emph{2D-Sphere-Index}-Index
	\item Geospatial Query Operators möglich:
		\begin{itemize}
		\item Alle Landebahnen im Umkreis von x km
		\item Alle Objekte mit Schnittpunkten mit Objekt X
		\item Abfrage Operator \texttt{\$geoIntersects}
		\end{itemize}
	\item gute Unterstützung für parallele Architekturen
	\item sehr gute Unterstützung durch Node.js
	\end{itemize}

	\note{
		\begin{itemize}
			\item parallele Architekturen wie 
			\item sharding
			\item sind aktuell sicherlich sehr gut verzichtbar
		\end{itemize}
	}

\end{frame}




\subsection{Express-Server App}

\begin{frame} {REST-API}{Express-Server}
	
	Die Funktionen des dataBaseManagers werden über eine REST-API per HTTP zur Verfügung gestellt.
	
	Es werden mehrere Endpunkte für HTTP-Requests zur Verfügung gestellt.
	
	\begin{itemize}
		\item GET auf \texttt{/}: HTML-Seite und JavaScript für den Client
		\item POST auf \texttt{/api/fileInfo/}: Dateiinformationen des über einen Dateinamen spezifizierten GeoTIFF
		\item POST auf \texttt{/api/fileInfo/extent}: konvexes Umfangspolygon 
		\item POST auf \texttt{/api/commands/}: Nimmt einen Task entgegen
		\begin{itemize}
			\item \texttt{SCAN}: Durchmustert einen Bereich nach Notlandefeldern. 
			\item \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei
		\end{itemize}
		\item DELETE auf \texttt{/api/commands/drop}: löscht Datenbank
		\item POST auf \texttt{/api/queries/}: liefert Einträge der Datenbank
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Inter Process Communication (IPC)}{Unix-Sockets}
	
	Die dataBaseManagerApp startet eine Instanz der searchEngine in einem eigenen Prozess.
	
	Es wird ein UNIX-Socket geöffnet um bidirektional zwischen den beiden Anwendungen zu kommunizieren.
	
\begin{itemize}
	\item DBM $\rightarrow$ SE \texttt{SCAN}: Durchmusterung eines Datensatzausschnitts. Parameter als JSON.
	\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei.
	\item SE $\rightarrow$ DBM \texttt{landingPlane}: SE hat potentielle Landebahn gefunden. Übergabe von minimaler und maximaler Bahn.
	\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Fertigstellung eines Durchmusterungs-Auftrags. 
\end{itemize}


	\note{
	\begin{itemize}
		\item DBM $\rightarrow$ SE \texttt{SCAN}: Es wird eine Durchmusterung eines Datensatzausschnitts in Auftrag gegeben. Die Parameter werden als JSON durchgereicht.
		\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert einen Bereich eines GeoTIFF Datensatzes in einer Matlab/GNU Octave kompatiblen Textdatei.
		\item SE $\rightarrow$ DBM \texttt{landingPlane}: Die SE hat eine neue potentielle Landebahn gefunden und übergibt sie über ein JSON-Objekt an den DBM um sie in der Datenbank zu persistieren. Für jede gefundene potentielle Bahn werden zwei Objekte übergeben: Die Bahn maximaler Ausdehung, so dass die geforderten Suchkriterien gerade noch eingehalten werden und eine innerhalb dieser Bahn liegende Teilbahn, welche minimale Varianz aufweist und gerade noch die geforderte Mindestlänge erreicht.
		\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Mit einem Task-Receipt meldet die SE dem DBM die Fertigstellung eines Auftrags. Damit kann der DBM nachhalten ob und welche Aufträge noch ausstehen und gegebenenfalls den Client aktiv informieren (Push). Aktuell wird diese Möglichkeit jedoch noch nicht genutzt.
	\end{itemize}
	}

\end{frame}

\subsection{Postprocessing - Merge}

\begin{frame} {Optionales Postprocessing}{Merge-Task}
	
	Es hat sich gezeigt, dass häufig viele nebeneinander liegende Landebahnen gefunden werden, die sich gegenseitig überlappen.
	
	Die Darstellung als einzelne Landebahnen ist unübersichtlich. Daher ist es sinnvoll überlappende Bahnen zusammen zu fassen.
	
		\begin{columns}
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/planesToMerge.png}
				\end{figure}
				
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/mergedPlanes.png}
				\end{figure}
		\end{columns}
		

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Postprocessing}{Merge Proof of concept}
	
	Innerhalb der Quelltextbasis des dataBaseManagers wurde ein unabhängiger Merge-Task implementiert.
	
	Dieser Task läuft vollkommen unabhängig von den anderen Komponenten als reines Postprocessing ab.
	
	\pause
	Der Algorithmus ist sehr einfach gehalten.
	\begin{itemize}
	\item Suche nacheinander alle unbearbeiteten Bahnen aus der DB
	\item für jede gefundene unbearbeitete Bahn:
		\begin{itemize}
		\item Starte DB-Abfrage nach überlappenden Bahnen
		\item Fasse alle überlappenden Bereiche zusammen
		\item Markiere Original-Bahn als Bearbeitet
		\item Lösche kleinere komplexe Polygone aus der DB
		\end{itemize}
	\end{itemize}
	
	\pause
	Aktuell muss dieser Merge-Lauf noch manuell gestartet werden und ist aufgrund der vielen Datenbankzugriffe vergleichsweise langsam.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\section{Komponente "'landingClient"'}

\subsection{Überblick}

\begin{frame} {Komponente "`landingClient"'}{GUI auf Basis moderner Webtechnologien}
	
	Als Benutzeroberfläche wurde ein Webclient auf Basis von React/Redux implementiert.
	
	\pause
	Gründe für die Implementierung eines Webclient:
	\begin{itemize}
	\pause
	\item Viele vorgefertigte Komponenten zur Kartendarstellung
	\pause
	\item Läuft auf jedem modernen Browser
	\pause
	\item Geräteunabhängigkeit
	\pause
	\item Betriebssystemunabhängigkeit
	\pause
	\item kein Vorwissen in der Arbeitsgruppe zur QT-Programmierung
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame} {Komponente "`landingClient"'}{Benutzeroberfläche}
	\begin{figure}
		\includegraphics[width=\textwidth]{images/LandingClient_Screen1.png}
	\end{figure}
\end{frame}

\begin{frame} {Komponente "`landingClient"'}{verwendete Technologien}
	
	Verwendete Technologien:
	\begin{itemize}
	\item React-Framework \hfill \includegraphics[height=0.7cm]{images/React_Logo.png}
	\item Redux-State-Management \hfill \includegraphics[height=0.7cm]{images/ReduxLogo.png}
	\item Bootstrap HTML-Framework \hfill \includegraphics[height=0.7cm]{images/bootstrapLogo.png}
	\item Leaflet mit OpenStreetMap-Karten \hfill \includegraphics[height=0.7cm]{images/LeafletLogo.png}
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{Grundlegende Funktionsweise}
	
	Grundlegende Arbeitsweise des \texttt{landingClient}:
	\begin{itemize}
	\item asynchrone HTTP-Kommunikation mit der REST-API des \texttt{dataBaseManager}
	\item Absetzen von Kommandos und Anfragen per JSON
	\item lokaler State-Container (REDUX-Store)
		\begin{itemize}
		\item Daten über ausgewählte GeoTIFF-Datei
		\item Daten über Landebahnen aus der Datenbank
		\end{itemize}
	\item lokales Filtern der angezeigten Daten
	\item lokales Rendering der Landebahnen auf einer Karte
	\end{itemize}

	\note{
		\begin{itemize}
			\item Hier kommt gleich eine Demo, die das in Live zeigt.
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{State-Container (REDUX-Store)}
	
	\begin{figure}
		\includegraphics[width=\textwidth]{images/ReduxStore_1.png}
	\end{figure}


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Features und Bedienung}

\begin{frame} {Komponente "`landingClient"'}{Features und Bedienung}
	
	Auswahl der GeoTIFF-Datei:
	
	\begin{figure}
		\includegraphics[width=0.7\textwidth]{images/LandingClient_Screen_Start.png}
	\end{figure}

	\pause		
	Anzeige der Ausdehnung des Datensatzes:
	\visible<2>{
		\begin{figure}
			\includegraphics[width=0.7\textwidth]{images/LandingClient_Screen_Ueberblick.png}
		\end{figure}
	}
	

	\note{
		\begin{itemize}
			\item Wir machen gleich eine Live Demo
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{Features und Bedienung}
	
	"'Workflow"':
	
	\begin{itemize}
	\item Wähle Datei aus
	\item Suche zu durchmusternden Ausschnitt 
	\item Lege Durchmusterungs-Parameter fest
	\item (Bestimme Anzahl Threads)
	\end{itemize}	
		\begin{figure}
			\includegraphics[width=\textwidth]{images/LandingClient_Parameter.png}
		\end{figure}
	\begin{itemize}
	\item Rufe Ergebnisse ab oder Verschiebe Karte
	\item Benutze die Filter
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Kommunikation mit dem dataBaseManager}

\begin{frame} {Komponente "`landingClient"'}{Kommunikation mit dem \texttt{dataBaseManager}}
	
	Der \texttt{landingClient} fragt bei diesen Gelegenheiten Daten beim \texttt{dataBaseManager} an:
	
	\begin{itemize}
	\item Änderung des dargestellten Kartenausschnitts
	\item Änderung des Filters für Merged- und Raw-Planes
	\item Maueller Abruf per "`Request Results"'
	\end{itemize}
	
	\pause
	Es werden immer nur die Landebahnen innerhalb des \\
	aktuell sichtbaren Ausschnitts übertragen.
	
	Beim Abruf von "`Merged-Planes"' werden \\
	die Rohbahnen nicht mit übertragen.
	
	Das Filtern nach Richtungen erfolgt lokal.
	
	\pause
	\skippingparagraph
	Aktuell wird noch kein Push-neuer Landebahnen vom \texttt{dataBaseManager} zum \texttt{landingClient} hin unterstützt.
	
	Das ließe sich über WebSockets realisieren.

	\note{
		\begin{itemize}
			\item React sorgt im Hintergrund dafür, dass beim Bewegen der Karte nicht zu viele ansichten gerendert werden, sondern nur diejeneigen, für die es sich auch lohnt.
			\item Virtual-DOM
			\item 
			\item Beim Abruf von "`Merged-Planes"' werden die Rohbahnen nicht mit übertragen. 
			\item Wenn eine Bahn noch nicht bearbeitet wurde (merge), dann wird sie trotzdem übertrage. $\Rightarrow$ Es gehen keine daten verloren.
		\end{itemize}
	}

\end{frame}




\section{Ausblick und weitere Ideen}

\subsection{Erreichung der Architekturziele}

\begin{frame} {Systemarchitektur}{Architekturziele}
	
	Wurden die Architekturziele erreicht?
	\skippingparagraph
	
	\begin{tabular}{lc}
		\pause inhärent und explizit parallel &  \textcolor{green}{\Checkmark}\\ 
		\pause lose gekoppelte Komponenten &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Einbindung externer Bibliotheken &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Erweiterbarkeit &  \textcolor{green}{\Checkmark}\\ 
		\pause Kommunikation über Standardprotokolle &  \textcolor{green}{\Checkmark}
	\end{tabular} 


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}
	
\subsection{Parallele Bearbeitung mehrerer Kacheln per MPI}

\begin{frame} {Weitere Parallelisierung}{Parallele Bearbeitung mehrerer Kacheln per MPI}
	
	Bei wirklich großen Datensätzen bietet sich eine weitere Parallelisierung per MPI an.
	
	Einzelne Kacheln können unabhängig voneinander auf verschiedenen MPI-Knoten durchmustert werden.
	
	\begin{figure}
		\includegraphics[height=0.5\textheight]{images/UeberlappungKacheln.png}
	\end{figure}
	
	Innerhalb jedes MPI-Knoten kann der lokal parallelisierte (\texttt{pthreads}) Durchmusterungscode verwendet werden.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Richtungskorrektur des GeoTIFF}
\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}
	
	\begin{columns}
		\column{0.5\textwidth}
	
		Aktuelle Schwäche der Implementierung:
		\begin{itemize}
		\item Aktuelle implizite Annahme: GeoTIFF-Raster ist perfekt nach Süden und Osten ausgerichtet.
		\item Verzerrungen durch Projektion der Kugel in die Ebene ist \emph{nicht} winkeltreu
		\item Richtungsinformationen weichen leicht von Geo-Koordinaten ab. 
		\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/NRW_Extent.png}
			\end{figure}
	\end{columns}


	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}

	Es ergibt sich eine geringe Abweichung von der korrekten Himmelsrichtung.
	
	\begin{figure}
		\includegraphics[height=0.5\textheight]{images/GeilenkirchenHeading.png}
	\end{figure}

	Die Landebahn der Geilenkirchen Airbase \\
	hat eine Ausrichtung von 09/27.
	
	Eine Durchmusterung findet \\
	leicht schief dazu liegende potentielle Landebahnen.


\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Möglichkeit zur Korrektur}

	Die Abweichung beträgt hier ungefähr 3\degree.
	
	Bei korrigierter Durchmusterungsrichtung kommen Karte und gefundene Bahnen zur Deckung.
	
	\begin{figure}
		\includegraphics[height=0.7\textheight]{images/GeilenkirchenHeading_corrected.png}
	\end{figure}


\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}
		In der \texttt{GDAL}-Library, die zum Einlesen der GeoTIFF Daten verwendet wird, finden sich auch passende Funktionen zur Richtungskorrektur.
		
		Zwei Möglichkeiten:
		\begin{itemize}
		\item einmalige Korrektur der Richtung, wenn die Durchmusterung neu aufsetzt
		\item kontinuierliche Richtungskorrektur beim Fortschreiten der Durchmusterung von Pixel zu Pixel
		\end{itemize}
		
		Beide Methoden lassen sich in die \texttt{GeoTiffHandler}-API integrieren.
		
		Es liegt ein Trade-Off zwischen höherem Rechenaufwand und notwendiger Genauigkeit vor.
		
		\note{
			\begin{itemize}
				\item Abweichungen in der NRW Karte viel größer als in der Hamburg Karte
				\item Demo:
				\item 
				\item Lade Hamburg-Karte
				\item Zoome auf Finkenwerder
				\item Lasse für 50° scannen und schalte Filter ein
				\item deutlich geringere Abweichung als in Geilenkirchen
			\end{itemize}
		}
	
		
	

\end{frame}



\subsection{Push für Webclient}
\begin{frame} {Push für \texttt{landingClient}}{}
	
%	Aktuell muss der Client von sich aus die Datenbank abfragen.
%	
%	Es wird keine Nachricht an den Client verschickt, wenn neue Landebahnen verfügbar sind.
	
	
	\begin{columns}
		\column{0.7\textwidth}
		
		Websockets:
		\begin{itemize}
		\item Es wird eine persistente Verbindung zwischen Client und Server hergestellt
		\item Über diese Verbindung sind bidirektionale Nachrichten möglich
		\item Der Server muss zusätzlichen Status verwalten (Verbindung pro Client)
		\end{itemize}
		
%		Aktuell war Funktionalität nicht notwendig, da häufig genug angefragt wird.
		
		Die Status-Verwaltung auf dem Server macht diesen deutlich schwergewichtiger.
	
		\column{0.3\textwidth}
			\begin{figure}
				\includegraphics[height=0.4\textheight]{images/WebSockets-Diagram.png}
			\end{figure}
			\smaller{\source{Websocket-Diagramm aus \url{https://www.pubnub.com/blog/2015-01-05-websockets-vs-rest-api-understanding-the-difference/}}}
	\end{columns}

	


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Merge als nachgeschalteter Prozess aus dem Speicher}

\begin{frame} {Merge Optimierung}{Merge als nachgeschalteter Prozess aus dem Speicher}
	
	Merge-Prozess läuft manuell angestoßen direkt auf der Datenbank.
	
	Die Performanz ist aufgrund vieler DB-Zugriffe sehr schlecht.
	
	\pause
	
	Verbesserungspotential:
	\begin{itemize}
	\item Implementiere Filterstufe in \texttt{dataBaseManager}
	\item Rohdaten werden vollständig an die DB durchgereicht
	\item Alle Bahnen eines Durchmusterungslaufs werden zusätzlich im Speicher gehalten
	\item Die Bahnen im Speicher werden direkt gemerged bevor sie geschrieben werden
	\item Nach jedem Durchmusterungslauf zusätzlicher Lauf über DB mit schon gemergeden Flächen
	\end{itemize}
	
	\pause
	Erwartete Performanz-Steigerung um Größenordnungen, da kein DB-Zugriff mehr benötigt wird.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\subsection{Kollisionsabfrage mit Objekten aus OSM}

\begin{frame} {Kollisionsabfrage mit Objekten aus OSM}{\texttt{Overpass API}}
	

	
	
	\begin{columns}
	\column{0.6\textwidth}

	OpenStreetMap beitet seine \texttt{Overpass API} an, um für weitere Informationen für bestimmte Bereiche abzufragen.
			
	Dazu gehören Informationen zur Oberflächenbeschaffenheit:
	\begin{itemize}
	\item \texttt{natural = water}
	\item \texttt{natural = grassland}
	\item \texttt{natural = tree\_row}
	\item \ldots
	\end{itemize}
	
	Diese Informationen können zusammen mit der \texttt{\$geoIntersects}-Abfrage auf der MongoDB die potentiellen Landeflächen bewerten.

	\column{0.4\textwidth}
		\begin{figure}
			\includegraphics[width=\textwidth]{images/OSM_Overpass_API.png}
		\end{figure}
	\end{columns}
	


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame}{Vielen Dank!}{Kein Vortrag ohne Katzenfotos}
	\begin{center}
%		\includegraphics[height=.8\textheight]{images/cat_with_Logo_HannoverJs.png}
		\includegraphics[height=.8\textheight]{images/cat_with_Logo_FernUni.png}

	\source{Katze aus \url{http://wallpapersinhq.online/20777-smiling_kitten_cats_tabby_cat_hd_wallpaper/}}
	\end{center}


\end{frame}
	
\end{document}


