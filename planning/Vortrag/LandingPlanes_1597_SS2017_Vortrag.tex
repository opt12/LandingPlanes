 % $Header$

\documentclass[
	xcolor=dvipsnames,
%	handout,
	hideallsubsections,
	xcolor=table
]{beamer} %xcolor=dvipsnames
%\documentclass[xcolor=dvipsnames, handout]{beamer} %xcolor=dvipsnames

\usepackage{pgfpages}

\mode<presentation>
{
	\usetheme{Rochester}
	\usecolortheme{wolverine}
%	\usecolortheme[named=TealBlue]{structure}
%	\usecolortheme[named=Dandelion]{structure}
	
	\setbeamercovered{transparent}
	% or whatever (possibly just delete it)
%	\setbeameroption{show notes} % un-comment to see the notes
%	\setbeameroption{show notes on second screen=right}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This LaTeX Beamer file is based on the solution template for:

% - Giving a talk on some subject.
% - The talk is between 15min and 45min long.
% - Style is ornate.

% Copyright 2004 by Till Tantau <tantau@users.sourceforge.net>.
%
% In principle, this file can be redistributed and/or modified under
% the terms of the GNU Public License, version 2.
%
% However, this file is supposed to be a template to be modified
% for your own needs. For this reason, if you use this file as a
% template and not specifically distribute it as part of a another
% package/program, I grant the extra permission to freely copy and
% modify this file as you see fit and even to delete this copyright
% notice. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Thank you so much Till :-)


\usepackage[ngerman]{babel}
% or whatever

\usepackage[latin1]{inputenc}
% or whatever

\usepackage{times}
\usepackage[T1]{fontenc}
 
\input{structure.tex} % Include the structure.tex file which specified the document structure and layout
\usepackage{struktex}

% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.

\title[Notlandefelder aus Höhendaten] % (optional, use only with long paper titles)
{Erkennung von Notlandefeldern aus Höhendaten: \\
	Parallele Implementierung der Durchmusterung mit \texttt{pThreads}}

\author[] % (optional, use only with lots of authors)
{Felix~Eckstein, Dr. Björn Wittich}
% - Use the \inst{?} command only if the authors have different
%   affiliation.

%\institute[FernUni Hagen] % (optional, but mostly needed)
%{
%}
  
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

\date[] % (optional)
{``1597 -- Fachpraktikum Parallele Programmierung''\\
	im Sommersemester 2017 an der FernUniversität Hagen\\
23. September 2017}

\subject{Talks}
% This is only inserted into the PDF information catalog. Can be left
% out. 



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=1cm]{university-logo}{images/HannoverJs.png}
  \pgfdeclareimage[height=1cm]{university-logo}{images/UniHagen.png}
 \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSection[]
{
  \begin{frame}<beamer> {Outline}
%    \tableofcontents[currentsection]%,currentsubsection]
    \tableofcontents[sections=\thesection]
  \end{frame}
}

\begin{document}

\begin{frame}
  \titlepage
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}



\begin{frame} {Outline}
  	\tableofcontents[hideallsubsections]
	\note{
		\begin{itemize}
			\item In den \textbackslash note Abschnitt kommen Vortragsnotizen
			\item \ldots
		\end{itemize}
			
	Kein Vortrag ohne Katzenfotos!
	}
\end{frame}


% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:  

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\setcounter{framenumber}{\value{framenumber}-1}	%no idea why it otherwise skips one page
\section{Aufgabenstellung}

\begin{frame} {Title}{Subtitle}
	


	\note{
		\begin{itemize}
			\item ACHTUNG: Im folgenden wird häufig das Word "`planes"' verwendet. 
			\item Es ist die Bedeutung im Sinne von "`Ebene"' gemeint.
			\item Das es gleichzeitig auch noch "`Flugzeug"' heißt, ist Zufall
			\item Pun intended!
		\end{itemize}
	}

\end{frame}

\begin{frame} {titel}
	
\begin{itemize}[<+->]
	\item<1-> 
	\begin{itemize}[<+->]
		\item<+-> 
		\item<+-> 
		\item<+-> 
		\item<+-> 
	\end{itemize}
	\item<+-> 
\end{itemize}

\note{
	
}
\end{frame}
	
\section{Architektur}

\subsection{Architekturziele}

\begin{frame} {Systemarchitektur}{Anforderungen}
	
	Anforderungen an die Architektur:
	
	\begin{itemize}
	\item inhärent und explizit parallel
	\item lose gekoppelte Komponenten
	\item einfache Einbindung externer Bibliotheken
	\item einfache Erweiterbarkeit
	\item Kommunikation über Standardprotokolle
	\end{itemize}
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Überblick}

\begin{frame} {Systemarchitektur}{Überblick}
	
	Die Architektur implementiert ein MVW (Model View Whatever) Modell:
	
	\begin{figure}
		\includegraphics[height=.8\textheight]{images/Architektur.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item Model: Datenbank
			\item View: userInterface
			\item Whatever hier:
			\begin{itemize}
			\item Controller: DataBaseManager
			\item Businnes Logic: searchEngine
			\end{itemize}
		\end{itemize}
	}

\end{frame}

\subsection{Komponenten}

\begin{frame} {Systemarchitektur}{Komponenten}
	
	Es sind insgesamt vier Hauptkomponenten zu erkennen:
	
	\begin{columns}
		\column{0.45\textwidth}
	\begin{itemize}
	\item das UserInterface
	\item der DataBaseManager
	\item die SearchEngine
	\item die Datenbank
	\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/Architektur.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Systemarchitektur}{Kommunikation der Komponenten}
	
	Die Kommunikation der Komponenten findet statt über
	
	\begin{itemize}
	\item HTTP: als Schnittstelle vom UserInterface zum dataBaseManager (REST-API)
	\item Unix-Sockets: zur Interprozesskommunikation zwischen dataBaseManager und searchEngine
	\item HTTP: als Schnittstelle vom dataBaseManager zur Datenbank
	\end{itemize}
	
	Die Schnittstellen sind klar definiert und die Kommunikation findet immer über den dataBaseManager statt.
	
	\skippingparagraph
	Das Datenformat der ausgetauschten Nachrichten ist JSON.
	
	

	\note{
		\begin{itemize}
			\item REST-API: Representational State Transfer: Die Bezeichnung ?Representational State Transfer? soll den Übergang vom aktuellen Zustand zum nächsten Zustand (state) einer Applikation verbildlichen. Dieser Zustandsübergang erfolgt durch den Transfer der Daten, die den nächsten Zustand repräsentieren.
		\end{itemize}
	}

\end{frame}

\subsection{Programmiersysteme}

\begin{frame} {Systemarchitektur}{Auswahl der Programmiersysteme}
	
	Für die Realisierung der einzelnen Komponenten wurden unterschiedliche Technologien verwendet:
	
	\begin{itemize}
	\item C/C++ für die searchEngine
		\begin{itemize}
		\item beste Performance für kritische Datenverarbeitung
		\item gute Parallelisierungsmöglichkeiten für Number Crunching
		\item gute Bibliotheksunterstützung in der Geo-Data Community
		\end{itemize}

	\item HTML/React für das userInterface
		\begin{itemize}
		\item Standard-Webtechnologien zur Realisierung des View
		\item Sehr gute, leicht zu bedienende Darstellungskomponenten
		\item Leichte Erweiterbarkeit und iterative Realisierungsmöglichkeit
		\item Vorwissen für GUI-Realisierung
		\end{itemize}

	\item Node.js/Javascript für den dataBaseManager
		\begin{itemize}
		\item Leichte Integration der Schnittstellen zu anderen Komponenten
		\item Native Unterstützung des JSON-Datenformats
		\item leichtgewichtiger Webserver
		\item sehr gute Unterstützung zum Interfacing der Datenbank
		\end{itemize}
	\end{itemize}
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Parallelität}

\begin{frame} {Systemarchitektur}{Parallelität}
	
	In der vorgestellten Architektur ist Raum für
	\begin{itemize}
	\item grobkörnige Parallelität
		\begin{itemize}
		\item jede vorgestellte Komponente läuft unabhängig von den anderen
		\item Aufteilung auf verschiedene Maschinen möglich
		\item parallele Abarbeitung in mehreren Prozessen auf einer Maschine
		\end{itemize}
	\item feingranulare Parallelität
		\begin{itemize}
		\item die rechenintensive Durchmusterung kann leicht parallelisiert werden
		\item \texttt{pthreads} ist gut geeignet, da gemeinsame Datenbasis genutzt werden kann
		\end{itemize}
	\end{itemize}

	\note{
		\begin{itemize}
		\item durch die verwendeten Protokolle ist Aufteilung auf verschiedene Maschinen möglich
		\end{itemize}
	}

\end{frame}


\section{Komponentenüberblick}
\begin{frame} {Komponentenübersicht}{}
	
Überblick über die Implementierung der einzelnen Komponenten.

	\begin{itemize}
	\item searchEngine mit Durchmusterung
		\begin{itemize}
		\item Überblick über die Datenformate und Vorverarbeitung
		\item Details zum Durchmusterungsalgorithmus und dessen Parallelisierung
		\end{itemize}
	\item dataBaseManager und Datenbank
	\item landingClient als User Interface
	\end{itemize}
	
	Alle Komponenten sollen vorgestellt werden.\\
	Der wichtigste Einzelaspekt ist die Durchmusterung und deren Parallelisierung.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Komponente "`searchEngine"'}

\begin{frame} {Komponente "`searchEngine"'}{Überblick}
	
	Die Komponente searchEngine realisiert die "Geschäftslogik"' der Applikation.\\
	
	Die Komponente ist in zwei Hauptbestandteile aufgeteilt:
	
		\begin{columns}
			\column{0.4\textwidth}
			\begin{itemize}
			\item Datenmanagement und Job Scheduling
			\item Durchmusterung / Number Crunching
			\end{itemize}
	
			\column{0.75\textwidth}
				\begin{figure}
					\includegraphics[width=\textwidth]{images/searchEngine_Komponenten.png}
				\end{figure}
		\end{columns}
	
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`searchEngine"'}{Threading innerhalb der Komponente}
	
	Innerhalb der searchEngine wird exzessiv Gebrauch von Multi-Threading gemacht\\
	\begin{figure}
		\includegraphics[width=\textwidth]{images/searchEngine_Threading.png}
	\end{figure}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Datenformate und Verarbeitung}
\begin{frame} {Datenformate und Verarbeitung}{}
	
	Es gibt drei wichtige Datenformate für die Anwendung:
	\begin{itemize}
	\item GeoTIFF
	\item JSON - JavaScript Object Notation
	\item GeoJSON
	\end{itemize}
	
%	Kurzer Überblick über die Eigenschaften

	\note{
		\begin{itemize}
			\item Vor der weiteren Betrachtung von Details der Implementierung ist es notwendig
			\item Eigenschaften und Grundlagen der verwendeten Datenformate 
			\item zu erklären
		\end{itemize}
	}

\end{frame}

\subsubsection{GeoTIFF}

\begin{frame} {GeoTIFF}{Überblick -- Grundlagen}
	
	\begin{itemize}
	\item 	GeoTIFF basiert auf TIFF, einem verlustfrei komprimierenden Rasterformat für Bilder.
	\item 	TIFF kann beliebige Größen annehmen.
	\item 	TIFF bietet im Dateiformat die Möglichkeit zu jedem einzelnen Pixel beliebige zusätzliche Informationen zu speichern.
	\end{itemize}
	
	\pause
	
	\begin{itemize}
	\item 	GeoTIFF bindet jedes Pixel eindeutig an einen Koordinatenpunkt auf der Erdoberfläche.
	\item 	Es werden Daten wie Höhe, Temperatur, Bewuchs, \ldots als Informationen in die Pixel kodiert.
	\item 	Enthält entweder Sidecar-Files oder Metadaten mit Informationen zur Projektion. Damit gelingt die eindeutige Zuordnung von Pixeln auf Geo-Koordinaten.
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Beispiel-Datensatz}
	
	Ein Beispiel der hier verwendeten Höhendatensätze:
	
	\only<1>{
		Die Angaben zur Projektion:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.prj}
		
		Die Angaben zur Skalierung:
		\lstinputlisting[style=JSStyle]{snippets/DTM_Hamburg_20m.tfw}
	}
	
	\only<2>{
	Die Übersicht über das im GeoTIFF erfasste Gebiet.
	\begin{figure}
		\includegraphics[height=0.75\textheight]{images/Gebiet_HH.png}
	\end{figure}
	\smaller{\smaller{Höhen sind als Farbwerte umgesetzt.}}
	}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\subsubsection{Speicherformat: GeoJSON}

\begin{frame} {JSON und GeoJSON}{Überblick}
	
	\begin{columns}
		\column{0.60\textwidth}
		JSON als Datenformat für
		\begin{itemize}
		\item Taskbeschreibungen bei der IPC
		\item Beschreibung gefundener Bahnen über REST-API
		\item GeoJSON zur Speicherung in der Datenbank
		\item GeoJSON zur Darstellung in OpenStreetMap
		\end{itemize}
	
		\column{0.40\textwidth}
			\smaller\smaller\lstinputlisting[style=JSStyle]{snippets/taskDescription.json}
	\end{columns}

	\note{
		\begin{itemize}
			\item Beispiel eines Durchmusterungsauftrags an die searchEngine
		\end{itemize}
	}

\end{frame}


\subsection{GeoTIFFHandler}

\begin{frame} {GeoTIFF-Handler}{vollständige Abstraktion zur Weiterverwendung bei der Durchmusterung}
	
	Die Klasse \texttt{GeoTiffHandler} abstrahiert vollständig von dem zugrundeliegenden Datenformat:
	\begin{itemize}
	\item Durchmusterung rein auf Pixeln
	\item notwendige Metainformationen (Pixelgröße) werden geliefert
	\item Koordinatentransformationen durch Service-Routinen
	\item automatische Speicherverwaltung und (wenn nötig) Kachelung
	\end{itemize}

	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{Verarbeitung}
	
	Es ist nicht notwendig die Einlese- und Verarbeitungsroutinen selber zu schreiben.
	
	Es gibt eine OpenSource-Bibliothek \texttt{libtiff}, welche alle Funktionen zur Verfügung stellt.
	
	Weitergehende Bibliothek: \texttt{LargeTiffTools} mit \texttt{tifffastcrop}
	\begin{itemize}
	\item sehr schnelles Einlesen von Teilbildern
	\item es werden nur so viele Daten gelesen wie unbedingt notwendig
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {GeoTIFF}{automatische Kachelung bei kleinem Speicher}
	
	Bestimmung der Einlesegröße nach vorhandenem Speicher:	
	\begin{columns}
		\column{0.55\textwidth}
		\begin{itemize}
		\item Aufteilung auf Kacheln, die in den gemeinsamen Speicher passen
		\item Überlappung der Kacheln in den Randbereichen
			\begin{itemize}
			\item Minimum: 1 Mindestlänge der gesuchten Bahn
			\end{itemize}
		\end{itemize}

		\column{0.42\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/UeberlappungKacheln.png}
			\end{figure}
	\end{columns}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame} {GeoTIFF}{Verarbeitung - Koordinatentransformationen}
	
	Zur Einordnung der GeoTIFF Daten auf der Erdoberfläche werden Routinen aus der \texttt{GDAL}-Bibliothek verwendet
	
	\begin{itemize}
	\item \texttt{gdalinfo} als Dienstrogramm zur Abfrage der Metadaten eines GeoTIFF
	\item Umrechnung von Geo-Koordinaten im \texttt{WGS84}-System in Pixel-Koordinaten
	\item Umrechnung von Pixel-Koordinaten in  Geo-Koordinaten im \texttt{WGS84}-System
	\end{itemize}
	

	\note{
		\begin{itemize}
			\item Live-Demo mit \texttt{~/dev/LandingPlanes/terrain gdalinfo "DTM Hamburg 20m.tif" json}
			\item ?GeoTIFF Projections Transform List? listet über 40 verschiedene, offensichtlich gängige Projektionen für GeoTIFF Datensätze auf.
		\end{itemize}
	}

\end{frame}

\subsubsection{Das \texttt{GeoTIFFHandler}-Objekt}

\begin{frame} {\texttt{GeoTiffHandler}}{Datenabstraktion}
	
		\texttt{GeoTiffHandler} liefert für die Durchmusterung zwei wesentliche Datenstrukturen:
		
		{\smaller{\lstinputlisting[style=myCStyle]{snippets/datasetInfo.c}}}
		

		{\smaller{\lstinputlisting[style=myCStyle]{snippets/tilingCharacteristics.c}}}
		
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {\texttt{GeoTiffHandler}}{API}
	
		\texttt{GeoTiffHandler} stellt eine einfache API bereit:
		
		\smaller{\lstinputlisting[style=myCStyle]{snippets/geoTiffHandlerAPI.c}}
				
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}




\section{Komponente "'Durchmusterung"'}

\subsection{Durchmusterung der Geotiff Daten und Auffinden der Landebahnen}
\begin{frame} {Übersicht}{}
		 Kapselung der Suchlogik
		 
		 Objektorientierter Ansatz zur besseren Wartbarkeit
		 
		 Komponente wird in Form einer statischen Library (aus)geliefert
\end{frame}


\subsection{Interface der Library}
\begin{frame} {Interface der Library}{Definition}

\lstinputlisting[style=myCStyle]{snippets/Durchmusterungslibrary.c}


\begin{tabular}{ll}
 *actualTile & Zeiger auf das Geo-Kartenobjekt\\
 *myGeoTiffHandler & Zeiger auf GeoTiffHandler mit Hilfsfunktionen\\
 heading & Suchwinkel\\
 minLength & Mindestlänge in [m]\\
 width & Breite in [m]\\
 commSocket & Socket für Mongo DB Kommunikation\\
 *taskDescription & Taskbeschreibung\\
 noDataValue & Zahlenwert für undefinierte Kartenpunkte\\
 pixelSize & Auflösung der Rasterpunkte in [m]\\
 \end{tabular}   
\end{frame}

\subsection{Logischer Ablauf innerhalb der Landebahn-Erkennung}
\begin{frame}{Landebahnbestimmung}{Durchmusterungsalgorithmus in Pseudo-Code}
\begin{figure}
\scalebox{.37}{\begin{struktogramm}(100,200)
  \assign{Initialisierung $tile\_worker$ Objekt}
  \assign{berechne winkel-, steigungs- und holprigkeitsabhängige Parameter}
\forallin{für alle Startpunkte einer Landebahn in gegebener Richtung (Thread Pool)}
\assign{wähle den nächsten Punkt}
\ifthenelse[15]{1}{1}
{kurzreichweitige Steigung zum Vorgänger OK?}{\sTrue}{\sFalse}
\ifthenelse[17]{1}{6}
{checke Holprigkeit in Querrichtung}{\sTrue}{\sFalse}
\change
\ifthenelse[40]{1}{1}
{ist die aktuelle Landebahn länger als die Mindestlänge}{\sTrue}{\sFalse}
\assign{suche die beste Landebahn mit Mindestlänge}
\assign{speichere beide Landebahnen in der DB}
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\change
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\ifend
\change
\ifthenelse[30]{1}{1}
{ist die aktuelle Landebahn länger als die Mindestlänge}{\sTrue}{\sFalse}
\assign{suche die beste Landebahn mit Mindestlänge}
\assign{speichere beide Landebahnen in der DB}
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\change
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\assign{starte eine neue Landebahn mit aktuellem Punkt}
\ifend
\forallinend
\end{struktogramm}}
\label{nasshnlogisch}
\end{figure}
\end{frame}

\subsection{Initialisierung}
\begin{frame}{Ueberschrift1}{Ueberschrift2}
	\begin{tabular}{l}
		\pause - Instanziierung Workerobjekt\\ 
		\pause - Initialisierung von Schrittvektoren (winkelabhängig)\\
		\pause - Initialisierung von orthogonalen Schrittvektoren (Breite)\\
     	\pause - Bestimmung des Startpunktes zur Durchmusterung\\
		\pause - Bestimmung Anzahl zusammenhängender Punkte einer validen Bahn\\
	\end{tabular} 
\end{frame}

\subsection{Durchmusterung}
\begin{frame}{U1}{U2}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};
\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (4,5)--(5,4) node[left]{$1$};
\draw[->,ultra thick,dashed,red] (3,5)--(5,3) node[left]{$2$};
\draw[->,ultra thick,dashed,red] (0,5)--(5,0) node[right]{$3$};

\draw[->,ultra thick,dashed,red] (0,3)--(3,0) node[below]{$4$};

\draw[->,ultra thick,dashed,red] (0,1)--(1,0) node[below]{$5$};

\draw[-,ultra thick,dashed,blue] (5,5.5)--(-0.5,5.5) node[left]{};
\draw[->,ultra thick,dashed,blue] (-0.5,5.5)--(-0.5,0) node[left]{};
\end{tikzpicture}
\end{figure}
\end{frame}

\subsection{Durchmusterung}
\begin{frame}{U1}{U2}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};

\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (0,5)--(0,0) node[below]{$1$};
\draw[->,ultra thick,dashed,red] (1,5)--(1,0) node[below]{$2$};
\draw[->,ultra thick,dashed,red] (3,5)--(3,0) node[below]{$3$};
\draw[->,ultra thick,dashed,red] (5,5)--(5,0) node[below]{$4$};


\draw[->,ultra thick,dashed,blue] (-0,5.5)--(5,5.5) node[left]{};
\end{tikzpicture}
\end{figure}
\end{frame}

\subsection{posix Threads Definition}
\begin{frame} {posix Threads}{Definition - Standard}
	
	Warum Posix Threads?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - POSIX - Portable Operating System Interface\\ 
		\pause - Abstraktion zwischen Hardware und Threading\\
		\pause - erste Standardisierung 1988 (IEEE Std 1003.1-1988)\\
     	\pause - aktuellste Version IEEE Std 1003.1,2016 Edition \\
		\pause - nahezu  alle gängigen OS unterstützem p\_thread\\
	\end{tabular} 


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{posix Threads Umfang}

\begin{frame} {posix Threads}{Standard- was gehört dazu}
	
	Was ist im Standard definiert?
	\skippingparagraph
	
	\begin{tabular}{l}
		\pause - ca. 100 pthread Funktionen (prefix pthread\_)\\ 
		\pause - Thread Management\\
		\pause - Mutexes\\
		\pause - Condition Variables\\
		\pause - Synchronistation\\
	\end{tabular} 
	\skippingparagraph
	Was ist nicht enthalten?
		\skippingparagraph
	\begin{tabular}{l}
		\pause - Semaphoren\\ 
	\end{tabular} 
	\skippingparagraph
	
	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Parallelverarbeitung mittels p\_threads zum Finden der Landebahnen}
\begin{frame}{U1}{U2}
$\Rightarrow$ Master /Worker
	
$\Rightarrow$ Peer
	
$\Rightarrow$ Pipeline
	
	$\Rightarrow$ Thread-Pool
			\skippingparagraph
		\begin{tabular}{l}
		\pause - Ressourcenschonend\\
		 \pause - identische Initialisierung\\
		  \pause - ideal zur Performanz-Untersuchung\\
	\end{tabular} 
	\skippingparagraph
	Gesteuert via Semaphor
\end{frame}

\subsection{Parallelverarbeitung mittels p\_threads zum Finden der Landebahnen}
\begin{frame}{U1}{U2}
\begin{figure}
\centering
\begin{tikzpicture}
\draw[help lines, color=gray!30, dashed] (0,0) grid (4.9,4.9);
\draw[->,ultra thick] (0,5)--(5,5) node[right]{$x$};
\draw[->,ultra thick] (0,5)--(0,0) node[left]{$y$};
\draw[-,ultra thick] (5,5)--(5,0) node[left]{};
\draw[-,ultra thick] (0,0)--(5,0) node[right]{};

\draw[->,ultra thick,dashed,red] (4,5)--(5,4) node[left]{$1$};
\draw[->,ultra thick,dashed,red] (3,5)--(5,3) node[left]{$2$};
\draw[->,ultra thick,dashed,red] (0,5)--(5,0) node[right]{$3$};

\draw[->,ultra thick,dashed,red] (0,3)--(3,0) node[below]{$4$};

\draw[->,ultra thick,dashed,red] (0,1)--(1,0) node[below]{$5$};

\draw[-,ultra thick,dashed,blue] (5,5.5)--(-0.5,5.5) node[left]{};
\draw[->,ultra thick,dashed,blue] (-0.5,5.5)--(-0.5,0) node[left]{};


\end{tikzpicture}
\end{figure}

		\begin{itemize}
			\item blaue Linie entspricht dem Master
			\item rot sind die unabhängigen Threads
		\end{itemize}

\end{frame}

\subsection{Detaillierte Beschreibung des Suchalgorithmus}
\begin{frame}{U1}{U2}
	\begin{tabular}{l}
		\pause - hat der aktuelle Punkt gültige Höheninformationen?\\
		\pause - ist die Steigung zu seinem Vorgänger OK? (Holprigkeit)\\
		\pause - sind innerhalb von $\frac{1}{2}B$ in orthogonaler Richtung die Steitungen OK?\\
		\pause - ist die Holprigkeit aller orthogonaler Punkte gültig?\\
	\end{tabular} 
	\skippingparagraph
    Sind alle diese Punkte erfüllt, wird der Punkt in eine Liste aufgenommen
    
    Dies wird so lange wiederholt, bis 
    		\begin{itemize}
			\item der Kartenrand erreicht ist
			\item oder ein Punkt das Kriterium erfüllt
		\end{itemize}
    
 \end{frame}
 
 \subsection{Detaillierte Beschreibung des Suchalgorithmus}
\begin{frame}{U1}{U2}


    Sind alle diese Punkte erfüllt, werden zwei Landebahnen bestimmt:
   	\skippingparagraph 
	\begin{tabular}{l}
		\pause - die längstmögliche, die die max. Steigung nicht überschreitet\\
		\pause - die (Sub)Fläche mit der kleinsten Varianz über alle Punkte\\
	\end{tabular} 
		\skippingparagraph
	Die beiden gefundenen Bahnen werden in der MongoDB abgelegt
    
 \end{frame}
 
 
 
\subsection{Verwendete Datenstrukturen - Performanz}
\begin{frame}{U1}{U2}
Augenmerk lag auf der Verwendung von wenig komplexen Datenstrukturen

benutzt werden

	\begin{tabular}{ll}
		\pause - \texttt{vector< pair<int,int> >} & Referenz auf die Kartenpunkte\\
		\pause -  \texttt{int access\_single\_element(int\ x, int\ y)}& mapping 2D $\rightarrow$ 1D\\
	\end{tabular} 
	
   	\skippingparagraph 	

In der Durchmusterung sind alle Datenstrukturen in der Komplexitätsklasse $O(1)$ zu finden
	
	
\end{frame}
 

\subsection{Bestimmung des Speedups in Abhängigkeit des Parallelisierungsgrades}
\begin{frame}{U1}{U2}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  1 & 1 & \cellcolor{red!25}  11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  2 & 1 & \cellcolor{red!25}  11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  4 & 1 & \cellcolor{red!25} 11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  8 & 1 & \cellcolor{red!25}  11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25}  64 & 1 & \cellcolor{red!25}  10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 2 & 5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 4 & 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 4 & 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
 \end{frame}
 
 \begin{frame}{U1}{U2}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 1 & 2 & \cellcolor{red!25} 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 2 & 2 & \cellcolor{red!25} 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &\cellcolor{red!25}  4 & 2 & \cellcolor{red!25} 5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 1 & 4 & 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 2 & 4 & 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
 \end{frame}
 
 \begin{frame}{U1}{U2}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 2 &  5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 1 & 4 & \cellcolor{red!25} 8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 2 & 4 & \cellcolor{red!25} 4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 4 & 4 & \cellcolor{red!25} 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 8 & 4 & \cellcolor{red!25} 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & 16 & 8 & 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
 \end{frame}
 
 
  \begin{frame}{U1}{U2}
\begin{figure}
\scalebox{.37}{
\begin{tabular}{|c|c|c|c|c|c|}
\hline 
Richtung & Bahnen & \cellcolor{red!25}  Threads & \cellcolor{red!25}  v CPUs & \cellcolor{red!25}  Zeitbedarf [ms] & Standardabweichung [ms] \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 1 & 11409 & 510 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 1 &   11049& 216 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 1 &  11586 & 220 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 1 &   11230 & 240 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  64 & 1 &   10886 & 621 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 1 & 10442 & 239 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 64 & 1 & 10094 & 284 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 1 & 18147 & 327 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 1 & 18423 & 701 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 2 & 8488 & 46 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 2 & 5397 & 178 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  4 & 2 &  5545 & 161 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 1 & 2 & 8668 & 453 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 2 & 2 & 5778 & 292 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 1 & 2 & 15208 & 216 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 64 & 2 & 8976 & 327 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 &  1 & 4 &  8823 & 83 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  2 & 4 &  4642 & 77 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 & 4 & 4 & 2973 & 17 \\ 
\hline 
N$\rightarrow$S (0$^\circ$) & 734 &  8 & 4 & 3571 & 432 \\ 
\hline 
W$\rightarrow$O (90$^\circ$) & 1606 & 8 & 4 & 3335 & 72 \\ 
\hline 
NNO$\rightarrow$SSW (45$^\circ$) & 704 & 8 & 4 & 5406 & 442 \\ 
\hline
N$\rightarrow$S (0$^\circ$) & 734 & \cellcolor{red!25} 16 & 8 & \cellcolor{red!25} 2733 & 56 \\ 
\hline 
\end{tabular}
}
\end{figure}
 \end{frame}
\subsubsection{Erläuterung des Messverfahren}

\subsubsection{Messergebnisse}

\subsubsection{Diskussion der Messergebnisse}
\begin{frame}
\begin{tikzpicture} 
\begin{axis}[ 
  xlabel=Anzahl CPU, ylabel=Speedup, legend style={at={(axis cs:8.3,1)},anchor=south east}] 
  \addplot[color=red,mark=x] coordinates { 
  (1,1) 
  (2,2.11) 
  (4,3.84) 
  (8,4.2)   
  }; 
    \addplot[color=blue,mark=x] coordinates { 
  (1,1) 
  (2,1.8) 
  (4,3.13)    
  }; 
    \addplot[color=green,mark=x] coordinates { 
  (1,1) 
  (2,2.02) 
  (4,3.35)    
  }; 
    \addlegendentry{Nord-Süd}
  \addlegendentry{Ost-West}
    \addlegendentry{Nordnordwest-Südsüdost}
  \end{axis} 

  \end{tikzpicture}
\end{frame}

\subsection{Analyse mittels Profiler}
\begin{frame}

\end{frame}
\subsection{Einfluss von Compiler Direktiven (speziell Optimizer)}

\section{Komponente "`databaseManager"'}

\begin{frame} {dataBaseManager}{Überblick}
	
	\begin{columns}
		\column{0.6\textwidth}
		Die in einem separaten Prozess ablaufende Komponente \texttt{dataBaseManager} abstrahiert
		\begin{itemize}
		\item alle notwendigen Datenbankzugriffe
		\item einen Controller im MVC-Modell
			\begin{itemize}
			\item nimmt Benutzeranfragen entgegen
			\item verteilt Tasks an die searchEngine
			\item stellt Daten für die View bereit
			\end{itemize}
		\item realisiert einen Merge für Überlappende Landebahnen
		\end{itemize}

		\column{0.45\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/databaseManager_Komponenten.png}
			\end{figure}
	\end{columns}
	

	\note{
		\begin{itemize}
			\item Der Merge ist nicht Kernaufgabe des dataBaseManager, sondern ist hauptsächlich wegen seiner intensiven Datenbankzugriffe hier hinein gekommen.
		\end{itemize}
	}

\end{frame}


\subsection{Datenbankauswahl}

\begin{frame} {Datenbankauswahl}{Warum MongoDB?}

	\begin{tikzpicture}[remember picture,overlay]  
	  \node [xshift=-3.3cm,yshift=-.8cm] at (current page.north east)
	    {\includegraphics[width=4cm]{images/MongoDB_Logo.png}};
	\end{tikzpicture}
	
	Die Wahl der Datenbank fiel auf MongoDB.
	
	Gründe für MongoDB.
	\begin{itemize}
	\item direkte Unterstützung von GeoJSON
	\item ermöglicht \emph{2D-Sphere-Index}-Index
	\item Geospatial Query Operators möglich:
		\begin{itemize}
		\item Alle Landebahnen im Umkreis von x km
		\item Alle Objekte mit Schnittpunkten mit Objekt X
		\item Abfrage Operator \texttt{\$geoIntersects}
		\end{itemize}
	\item gute Unterstützung für parallele Architekturen
	\item sehr gute Unterstützung durch Node.js
	\end{itemize}

	\note{
		\begin{itemize}
			\item parallele Architekturen wie 
			\item sharding
			\item sind aktuell sicherlich sehr gut verzichtbar
		\end{itemize}
	}

\end{frame}




\subsection{Express-Server App}

\begin{frame} {REST-API}{Express-Server}
	
	Die Funktionen des dataBaseManagers werden über eine REST-API per HTTP zur Verfügung gestellt.
	
	Es werden mehrere Endpunkte für HTTP-Requests zur Verfügung gestellt.
	
	\begin{itemize}
		\item GET auf \texttt{/}: HTML-Seite und JavaScript für den Client
		\item POST auf \texttt{/api/fileInfo/}: Dateiinformationen des über einen Dateinamen spezifizierten GeoTIFF
		\item POST auf \texttt{/api/fileInfo/extent}: konvexes Umfangspolygon 
		\item POST auf \texttt{/api/commands/}: Nimmt einen Task entgegen
		\begin{itemize}
			\item \texttt{SCAN}: Durchmustert einen Bereich nach Notlandefeldern. 
			\item \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei
		\end{itemize}
		\item DELETE auf \texttt{/api/commands/drop}: löscht Datenbank
		\item POST auf \texttt{/api/queries/}: liefert Einträge der Datenbank
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Inter Process Communication (IPC)}{Unix-Sockets}
	
	Die dataBaseManagerApp startet eine Instanz der searchEngine in einem eigenen Prozess.
	
	Es wird ein UNIX-Socket geöffnet um bidirektional zwischen den beiden Anwendungen zu kommunizieren.
	
\begin{itemize}
	\item DBM $\rightarrow$ SE \texttt{SCAN}: Durchmusterung eines Datensatzausschnitts. Parameter als JSON.
	\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert GeoTIFF in Textdatei.
	\item SE $\rightarrow$ DBM \texttt{landingPlane}: SE hat potentielle Landebahn gefunden. Übergabe von minimaler und maximaler Bahn.
	\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Fertigstellung eines Durchmusterungs-Auftrags. 
\end{itemize}


	\note{
	\begin{itemize}
		\item DBM $\rightarrow$ SE \texttt{SCAN}: Es wird eine Durchmusterung eines Datensatzausschnitts in Auftrag gegeben. Die Parameter werden als JSON durchgereicht.
		\item DBM $\rightarrow$ SE \texttt{SAVE\_2\_M\_FILE}: Speichert einen Bereich eines GeoTIFF Datensatzes in einer Matlab/GNU Octave kompatiblen Textdatei.
		\item SE $\rightarrow$ DBM \texttt{landingPlane}: Die SE hat eine neue potentielle Landebahn gefunden und übergibt sie über ein JSON-Objekt an den DBM um sie in der Datenbank zu persistieren. Für jede gefundene potentielle Bahn werden zwei Objekte übergeben: Die Bahn maximaler Ausdehung, so dass die geforderten Suchkriterien gerade noch eingehalten werden und eine innerhalb dieser Bahn liegende Teilbahn, welche minimale Varianz aufweist und gerade noch die geforderte Mindestlänge erreicht.
		\item SE $\rightarrow$ DBM \texttt{taskReceipt}: Mit einem Task-Receipt meldet die SE dem DBM die Fertigstellung eines Auftrags. Damit kann der DBM nachhalten ob und welche Aufträge noch ausstehen und gegebenenfalls den Client aktiv informieren (Push). Aktuell wird diese Möglichkeit jedoch noch nicht genutzt.
	\end{itemize}
	}

\end{frame}

\subsection{Postprocessing - Merge}

\begin{frame} {Optionales Postprocessing}{Merge-Task}
	
	Es hat sich gezeigt, dass häufig viele nebeneinander liegende Landebahnen gefunden werden, die sich gegenseitig überlappen.
	
	Die Darstellung als einzelne Landebahnen ist unübersichtlich. Daher ist es sinnvoll überlappende Bahnen zusammen zu fassen.
	
		\begin{columns}
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/planesToMerge.png}
				\end{figure}
				
			\column{0.5\textwidth}
				\begin{figure}
					\includegraphics[height=0.5\textheight]{images/mergedPlanes.png}
				\end{figure}
		\end{columns}
		

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Postprocessing}{Merge Proof of concept}
	
	Innerhalb der Quelltextbasis des dataBaseManagers wurde ein unabhängiger Merge-Task implementiert.
	
	Dieser Task läuft vollkommen unabhängig von den anderen Komponenten als reines Postprocessing ab.
	
	\pause
	Der Algorithmus ist sehr einfach gehalten.
	\begin{itemize}
	\item Suche nacheinander alle unbearbeiteten Bahnen aus der DB
	\item für jede gefundene unbearbeitete Bahn:
		\begin{itemize}
		\item Starte DB-Abfrage nach überlappenden Bahnen
		\item Fasse alle überlappenden Bereiche zusammen
		\item Markiere Original-Bahn als Bearbeitet
		\item Lösche kleinere komplexe Polygone aus der DB
		\end{itemize}
	\end{itemize}
	
	\pause
	Aktuell muss dieser Merge-Lauf noch manuell gestartet werden und ist aufgrund der vielen Datenbankzugriffe vergleichsweise langsam.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\section{Komponente "'landingClient"'}

\subsection{Überblick}

\begin{frame} {Komponente "`landingClient"'}{GUI auf Basis moderner Webtechnologien}
	
	Als Benutzeroberfläche wurde ein Webclient auf Basis von React/Redux implementiert.
	
	Gründe für die Implementierung eines Webclient:
	\begin{itemize}
	\item Viele vorgefertigte Komponenten zur Kartendarstellung
	\item Läuft auf jedem modernen Browser
	\item Geräteunabhängigkeit
	\item Betriebssystemunabhängigkeit
	\item kein Vorwissen in der Arbeitsgruppe zur QT-Programmierung
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\begin{frame} {Komponente "`landingClient"'}{Benutzeroberfläche}
	\begin{figure}
		\includegraphics[width=\textwidth]{images/LandingClient_Screen1.png}
	\end{figure}
\end{frame}

\begin{frame} {Komponente "`landingClient"'}{verwendete Technologien}
	
	Verwendete Technologien:
	\begin{itemize}
	\item React-Framework \hfill \includegraphics[height=0.7cm]{images/React_Logo.png}
	\item Redux-State-Management \hfill \includegraphics[height=0.7cm]{images/ReduxLogo.png}
	\item Bootstrap HTML-Framework \hfill \includegraphics[height=0.7cm]{images/bootstrapLogo.png}
	\item Leaflet mit OpenStreetMap-Karten \hfill \includegraphics[height=0.7cm]{images/LeafletLogo.png}
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{Grundlegende Funktionsweise}
	
	Grunbdlegende Arbeitsweise des \texttt{landingClient}:
	\begin{itemize}
	\item asynchrone HTTP-Kommunikation mit der REST-API des \texttt{dataBaseManager}
	\item Absetzen von Kommandos und Anfragen per JSON
	\item lokaler State-Container (REDUX-Store)
		\begin{itemize}
		\item Daten über ausgewählte GeoTIFF-Datei
		\item Daten über Landebahnen aus der Datenbank
		\end{itemize}
	\item lokales Filtern der angezeigten Daten
	\item lokales Rendering der Landebahnen auf einer Karte
	\end{itemize}

	\note{
		\begin{itemize}
			\item Hier kommt gleich eine Demo, die das in Live zeigt.
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{State-Container (REDUX-Store)}
	
	\begin{figure}
		\includegraphics[width=\textwidth]{images/ReduxStore_1.png}
	\end{figure}


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Features und Bedienung}

\begin{frame} {Komponente "`landingClient"'}{Features und Bedienung}
	
	Auswahl der GeoTIFF-Datei:
	
	\begin{figure}
		\includegraphics[width=0.7\textwidth]{images/LandingClient_Screen_Start.png}
	\end{figure}

	\pause		
	Anzeige der Ausdehnung des Datensatzes:
	\begin{figure}
		\includegraphics[width=0.7\textwidth]{images/LandingClient_Screen_Ueberblick.png}
	\end{figure}
	

	\note{
		\begin{itemize}
			\item Wir machen gleich eine Live Demo
		\end{itemize}
	}

\end{frame}

\begin{frame} {Komponente "`landingClient"'}{Features und Bedienung}
	
	"'Workflow"':
	
	\begin{figure}
		\includegraphics[width=\textwidth]{images/LandingClient_Parameter.png}
	\end{figure}

	\begin{itemize}
	\item Wähle Datei aus
	\item Suche zu durchmusternden Ausschnitt 
	\item Lege Durchmusterungs-Parameter fest
	\item (Bestimme Anzahl Threads)
	\item Rufe Ergebnisse ab oder Verschiebe Karte
	\item Benutze die Filter
	\end{itemize}

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

\subsection{Kommunikation mit dem dataBaseManager}

\begin{frame} {Komponente "`landingClient"'}{Kommunikation mit dem \texttt{dataBaseManager}}
	
	Der \texttt{landingClient} fragt bei diesen Gelegenheiten Daten beim \texttt{dataBaseManager} an:
	
	\begin{itemize}
	\item Änderung des dargestellten Kartenausschnitts
	\item Änderung des Filters für Merged- und Raw-Planes
	\item Maueller Abruf per "`Request Results"'
	\end{itemize}
	
	\pause
	Es werden immer nur die Landebahnen innerhalb des \\
	aktuell sichtbaren Ausschnitts übertragen.
	
	Beim Abruf von "`Merged-Planes"' werden \\
	die Rohbahnen nicht mit übertragen.
	
	Das Filtern nach Richtungen erfolgt lokal.
	
	\pause
	\skippingparagraph
	Aktuell wird noch kein Push-neuer Landebahnen vom \texttt{dataBaseManager} zum \texttt{landingClient} hin unterstützt.
	
	Das ließe sich über WebSockets realisieren.

	\note{
		\begin{itemize}
			\item React sorgt im Hintergrund dafür, dass beim Bewegen der Karte nicht zu viele ansichten gerendert werden, sondern nur diejeneigen, für die es sich auch lohnt.
			\item Virtual-DOM
			\item 
			\item Beim Abruf von "`Merged-Planes"' werden die Rohbahnen nicht mit übertragen. 
			\item Wenn eine Bahn noch nicht bearbeitet wurde (merge), dann wird sie trotzdem übertrage. $\Rightarrow$ Es gehen keine daten verloren.
		\end{itemize}
	}

\end{frame}




\section{Ausblick und weitere Ideen}

\subsection{Erreichung der Architekturziele}

\begin{frame} {Systemarchitektur}{Architekturziele}
	
	Wurden die Architekturziele erreicht?
	\skippingparagraph
	
	\begin{tabular}{lc}
		\pause inhärent und explizit parallel &  \textcolor{green}{\Checkmark}\\ 
		\pause lose gekoppelte Komponenten &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Einbindung externer Bibliotheken &  \textcolor{green}{\Checkmark}\\ 
		\pause einfache Erweiterbarkeit &  \textcolor{green}{\Checkmark}\\ 
		\pause Kommunikation über Standardprotokolle &  \textcolor{green}{\Checkmark}
	\end{tabular} 


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}
	
\subsection{Parallele Bearbeitung mehrerer Kacheln per MPI}

\begin{frame} {Weitere Parallelisierung}{Parallele Bearbeitung mehrerer Kacheln per MPI}
	
	Bei wirklich großen Datensätzen bietet sich eine weitere Parallelisierung per MPI an.
	
	Einzelne Kacheln können unabhängig voneinander auf verschiedenen MPI-Knoten durchmustert werden.
	
	\begin{figure}
		\includegraphics[height=0.5\textheight]{images/UeberlappungKacheln.png}
	\end{figure}
	
	Innerhalb jedes MPI-Knoten kann der lokal parallelisierte (\texttt{pthreads}) Durchmusterungscode verwendet werden.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Richtungskorrektur des GeoTIFF}
\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}
	
	\begin{columns}
		\column{0.5\textwidth}
	
		Aktuelle Schwäche der Implementierung:
		\begin{itemize}
		\item Aktuelle implizite Annahme: GeoTIFF-Raster ist perfekt nach Süden und Osten ausgerichtet.
		\item Verzerrungen durch Projektion der Kugel in die Ebene ist \emph{nicht} winkeltreu
		\item Richtungsinformationen weichen leicht von Geo-Koordinaten ab. 
		\end{itemize}

		\column{0.6\textwidth}
			\begin{figure}
				\includegraphics[width=\textwidth]{images/NRW_Extent.png}
			\end{figure}
	\end{columns}


	\note{
		\begin{itemize}
			\item Richtungs-Abweichungen betragen wenige Grad 
			\item Für diesen Proof-of-concept wurde das toleriert
			\item Korrektur der richtungen über weitere \texttt{GDAL}-Routinen relativ leicht möglich
			\item $\Rightarrow$ Trade-off zwischen Genauigkeit und Rechenleistung notwendig
		\end{itemize}
	}

\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}

	Es ergibt sich eine geringe Abweichung von der korrekten Himmelsrichtung.
	
	\begin{figure}
		\includegraphics[height=0.5\textheight]{images/GeilenkirchenHeading.png}
	\end{figure}

	Die Landebahn der Geilenkirchen Airbase \\
	hat eine Ausrichtung von 09/27.
	
	Eine Durchmusterung findet \\
	leicht schief dazu liegende potentielle Landebahnen.



\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Möglichkeit zur Korrektur}

	Die Abweichung beträgt hier ungefähr 3\degree.
	
	Bei korrigierter Durchmusterungsrichtung kommen Karte und gefundene Bahnen zur Deckung.
	
	\begin{figure}
		\includegraphics[height=0.7\textheight]{images/GeilenkirchenHeading_corrected.png}
	\end{figure}


\end{frame}

\begin{frame} {{Richtungskorrektur des GeoTIFF}}{Implementierungsschwäche}
		In der \texttt{GDAL}-Library, die zum Einlesen der GeoTIFF Daten verwendet wird, finden sich auch passende Funktionen zur Richtungskorrektur.
		
		Zwei Möglichkeiten:
		\begin{itemize}
		\item einmalige Korrektur der Richtung, wenn die Durchmusterung neu aufsetzt
		\item kontinuierliche Richtungskorrektur beim Fortschreiten der Durchmusterung von Pixel zu Pixel
		\end{itemize}
		
		Beide Methoden lassen sich in die \texttt{GeoTiffHandler}-API integrieren.
		
		Es liegt ein Trade-Off zwischen höherem Rechenaufwand und notwendiger Genauigkeit vor.
	

\end{frame}



\subsection{Push für Webclient}
\begin{frame} {Push für \texttt{landingClient}}{}
	
%	Aktuell muss der Client von sich aus die Datenbank abfragen.
%	
%	Es wird keine Nachricht an den Client verschickt, wenn neue Landebahnen verfügbar sind.
	
	
	\begin{columns}
		\column{0.7\textwidth}
		
		Websockets:
		\begin{itemize}
		\item Es wird eine persistente Verbindung zwischen Client und Server hergestellt
		\item Über diese Verbindung sind bidirektionale Nachrichten möglich
		\item Der Server muss zusätzlichen Status verwalten (Verbindung pro Client)
		\end{itemize}
		
%		Aktuell war Funktionalität nicht notwendig, da häufig genug angefragt wird.
		
		Die Status-Verwaltung auf dem Server macht diesen deutlich schwergewichtiger.
	
		\column{0.3\textwidth}
			\begin{figure}
				\includegraphics[height=0.4\textheight]{images/WebSockets-Diagram.png}
			\end{figure}
			\smaller{\source{Websocket-Diagramm aus \url{https://www.pubnub.com/blog/2015-01-05-websockets-vs-rest-api-understanding-the-difference/}}}
	\end{columns}

	


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}



\subsection{Merge als nachgeschalteter Prozess aus dem Speicher}

\begin{frame} {Merge Optimierung}{Merge als nachgeschalteter Prozess aus dem Speicher}
	
	Merge-Prozess läuft manuell angestoßen direkt auf der Datenbank.
	
	Die Performanz ist aufgrund vieler DB-Zugriffe sehr schlecht.
	
	\pause
	
	Verbesserungspotential:
	\begin{itemize}
	\item Implementiere Filterstufe in \texttt{dataBaseManager}
	\item Rohdaten werden vollständig an die DB durchgereicht
	\item Alle Bahnen eines Durchmusterungslaufs werden zusätzlich im Speicher gehalten
	\item Die Bahnen im Speicher werden direkt gemerged bevor sie geschrieben werden
	\item Nach jedem Durchmusterungslauf zusätzlicher Lauf über DB mit schon gemergeden Flächen
	\end{itemize}
	
	\pause
	Erwartete Performanz-Steigerung um Größenordnungen, da kein DB-zugriff mehr benötigt wird.

	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}


\subsection{Kollisionsabfrage mit Objekten aus OSM}

\begin{frame} {Kollisionsabfrage mit Objekten aus OSM}{\texttt{Overpass API}}
	

	
	
	\begin{columns}
	\column{0.6\textwidth}

	OpenStreetMap beitet seine \texttt{Overpass API} an, um für weitere Informationen für bestimmte Bereiche abzufragen.
			
	Dazu gehören Informationen zur Oberflächenbeschaffenheit:
	\begin{itemize}
	\item \texttt{natural = water}
	\item \texttt{natural = grassland}
	\item \texttt{natural = tree\_row}
	\item \ldots
	\end{itemize}
	
	Diese Informationen können zusammen mit der \texttt{\$geoIntersects}-Abfrage auf der MongoDB die potentiellen Landeflächen bewerten.

	\column{0.4\textwidth}
		\begin{figure}
			\includegraphics[width=\textwidth]{images/OSM_Overpass_API.png}
		\end{figure}
	\end{columns}
	


	\note{
		\begin{itemize}
			\item 
		\end{itemize}
	}

\end{frame}

	
\end{document}


